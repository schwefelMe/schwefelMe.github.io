<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于我-软工作业搬家版</title>
      <link href="/posts/52607.html"/>
      <url>/posts/52607.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于我-不完全版"><a href="#关于我-不完全版" class="headerlink" title="关于我-不完全版"></a>关于我-不完全版</h1><p>令我魂牵梦绕的 $S_2O_8^{2}$ 它终于能显示出来了哈哈哈</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h3 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h3><p>我是 <code>032004123</code>，就读于福州大学2020级数据科学与大数据技术 专业。（上课听到学号可以作为<u>码</u>唯一标识实体，<del>串课了</del>）来自福建漳州——养老的第一选择，还能感受优美的闽南话（bushi）。</p><p><del>18岁</del>。🧠留在2020年了</p><h3 id="❓为哈要起这么一个博客名字呢"><a href="#❓为哈要起这么一个博客名字呢" class="headerlink" title="❓为哈要起这么一个博客名字呢"></a>❓为哈要起这么一个博客名字呢</h3><p>当然是源于对化学的热爱啊！</p><p>可能吗？可能吗？难道我第一志愿报化学最后被调剂到计算机吗？</p><p>起因是“硫有负二正四六”。 初三的不懂事激起了我对化学的兴趣，高中我就成了流水的化学老师，铁打的化学课代表（因为初代老师在我高一时怀上了宝宝，托小宝宝的福，有幸体验了每天不一样化学老师的快乐，这种 ==新鲜感== 陪我度过了枯燥的高一）。高二时化学老师定下来了，私下关系也不错（在那个查手机的年代，居然默许我带手机欸——指上课给我发消息，简直就是我滴神）。</p><p>有点说偏了，回到硫上面。在学习到硫的时候，依稀记得老师上课强调过硫没有正五价，只有负二正四六，好的我记住了，但考试往往出奇不意，出了个 $S_2O_8^{2}$ ，（好像是这个？）就现在我还是觉得他是正七价（管他的，反正我不读化学，怎么说都可以）。在这之后我的梦里就出现了格式各样的正七价的硫——拿着镰刀的、诡异微笑的…</p><p>于是便有了这个名字，<em>shout out to</em> 正七价的硫。<del>不存在人世间，却令我魂牵梦绕</del></p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>老广了，哈哈哈。为什么 ==新鲜感== 要高亮呢，它就是我学习生活的 <em>pemoline</em>。</p><p>小时候很喜欢看假面骑士（Faiz太帅了叭），觉得这是超越小孩认识范围的东西，是一种很新的东西，<del>看这个可以学到很多东西</del>。长大后发现，它确实是<u>很新的东西</u>。</p><p>🏸、❀🔪、🏀…</p><ul><li>🏸是一年级开始的，现在或者以后于我可能会是另一条工作的路欸。</li><li>🏀勇士总冠军！！！</li><li>❀🔪：<code>cardistry</code> 是一种挺小众的东西，咱拿扑克牌可是来干正经事的！和几个朋友在福建假期时也组织了几次聚会，很酷的，去看看视频来入坑。</li></ul><h3 id="专业相关"><a href="#专业相关" class="headerlink" title="专业相关"></a>专业相关</h3><p>思索了五分钟，并不知道写啥嘞，不能是因为没东西可以写吧，大三了耶！</p><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>比较熟悉的是</p><ul><li><code>Java</code></li></ul><p>其他</p><ul><li><code>C++</code> 写题用的</li><li><code>Python</code> 最近的 <code>ML</code> 课程和爬虫</li><li><code>tex</code> 曾经数学建模使得 <code>tex</code> 占据了我 <code>wakatime</code> 半壁江上（27h，<del>holy</del>）</li></ul><p><img src="https://s2.loli.net/2022/09/20/dQD6toERIzVhPMg.jpg" alt="再也不想碰建模"></p><p>正在学习</p><ul><li><code>Kotlin</code> 最近在看安卓（为什么更新换代这么快的，一堆的<code>deprecated</code> <span class="github-emoji" alias="cry" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">&#x1f622;</span>）</li><li><code>scala</code> 边看 <code>spaark</code> 边学，对于函数式编程的概念还没有很理解</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>一点点的 <code>springboot</code> 、<code>mybatis</code></li><li>一点点的 <code>vue</code></li></ul><p>自我评估</p><ul><li>我有的：<ul><li>一台电脑</li><li>一双手</li><li>与 <code>BUG</code> 奋战到底的决心（<del>你不要过来呀</del>）</li></ul></li><li>我认为我缺乏的：<ul><li>快速寻找 <code>BUG</code> 以及高效率 <code>debug</code> 的能力</li><li>巩固旧知识的习惯</li><li>团队协作开发的经验</li><li>不愿再碰但又不得不碰的稳定数学基础</li></ul></li></ul><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>大概率选择考研，同时试着投下实习，试试水</p><p>感觉还没做好进入工作阶段的准备，考研更多的是想再缓冲几年</p><p>短期目标先提高自己的硬实力吧，争取毕业前有东西且不止一点</p><hr><p>还想拥有一个健康的肺</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软工实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/345222.html"/>
      <url>/posts/345222.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="多阶段的决策问题"><a href="#多阶段的决策问题" class="headerlink" title="多阶段的决策问题"></a>多阶段的决策问题</h2><p>所谓多阶段决策是指这样一个决策过程：它可以分为若干个互相联系的阶段，在每一阶段分别对应着一组可以选取的决策，当每个阶段的决策选定以后，过程也就随之确定。把各个阶段的决策综合起来，构成一个决策序列，成为一个 <strong>策略</strong>。显然由于各个阶段选取的决策不同对应整个过程就可以有一系列不同的策略。当对过程采取某一策略时，可以得到一个确定的（或期望的）效果，采取不同的策略，就会得到不同的效果。多阶段决策问题，就是要在所有可能采取的策略中间选取一个最优的策略，使在预定的标准下得到最好的效果。</p><h2 id="最优原理与动态规划的数学模型"><a href="#最优原理与动态规划的数学模型" class="headerlink" title="最优原理与动态规划的数学模型"></a>最优原理与动态规划的数学模型</h2><h3 id="动态规划问题的解题思路"><a href="#动态规划问题的解题思路" class="headerlink" title="动态规划问题的解题思路"></a>动态规划问题的解题思路</h3><p>用动态规划方法解题的基本思路，是将一个 $n$ 阶段的决策问题转化依次求解 $n$ 个具有递推关系的单阶段决策问题，从而简化计算过程。其中逆序算法使用的较多。</p><p>多阶段转化为依次求解多个单阶段的决策问题时，一个重要特征就是将前面的解传递并纳入下一个阶段一并考虑，即做到求解的各阶段间具有 <strong>传递性</strong>。</p><h3 id="动态规划基本概念"><a href="#动态规划基本概念" class="headerlink" title="动态规划基本概念"></a>动态规划基本概念</h3><ol><li><strong>阶段（$stage$）</strong> 指一个问题需要做出决策的步数，通常用 $k$ 来表示问题包含的阶段数，称为 <strong>阶段变量</strong>。$k$ 的编号方法有两种：$(1)$ 顺序编号法，即初始阶段编号为 $1$，以后随进程逐渐增大；$(2)$ 逆序编号法，令最后一个阶段编号为 $1$，往前推时编号逐渐增大。一般采用顺序编号法。</li><li><strong>状态（$state$）</strong> 是动态规划中一个最关键的参数，既反映前面各阶段状态和决策的结局，又是本阶段做出决策的出发点和依据。状态时动态规划问题各阶段的传递点和结合点，第 $k$ 阶段的状态变量 $s_k$ 应包含该阶段之前决策过程的全部信息，做到从该阶段后做出的决策同这之前的状态和决策相互独立。各阶段的状态通常用状态变量 $s$ 来描述，向量中所含变量个数称为动态规划问题的维数。</li><li><strong>决策（decision）</strong> 指某阶段初从给定的状态出发，决策者在面临的若干种不同方案中做出的选择。决策变量 $x_k(s_k)$ 表示第 $k$ 阶段初状态为 $s_k$ 时对方案的选择。决策变量的取值要受到一定范围的限制，用 $D_k(s_k)$ 表示 $k$ 阶段状态为 $s_k$ 时决策允许的取值范围，称允许决策集合，因而有 <script type="math/tex; mode=display">x_k(s_k) \in D_k(s_k)</script></li><li><strong>策略（policy）和子策略（subpolicy）</strong>，动态规划问题各阶段决策组成的序列总体称作一个策略。含 $n$ 个阶段的动态规划问题的策略可写为 <script type="math/tex; mode=display">\{ x_1(1s_1),x_2(s_2),\cdots ,x_n(s_n) \}</script>把从某一阶段开始到过程最终的决策序列称为问题的子过程策略或子策略。从 $k$ 阶段起的子策略可写为 <script type="math/tex; mode=display">\{ x_k(s_k),x_{k+1}(s_{k+1}),\cdots ,x_n(s_n) \}</script></li><li><strong>状态转移律</strong>。从 $s<em>k$ 的某一状态值出发，当决策变量 $x_k(s_k)$ 的取值决定后来，下一阶段状态变量 $s</em>{k+1}$ 的取值也就随之确定。这种从上阶段的某一状态值到下阶段某一状态值的转移的规律称为状态转移律。显然下一阶段状态 $s_{k+1}$ 的取值时上阶段状态变量 $s_k$ 和上阶段决策变量 $x_k(s_k)$ 的函数，记为 <script type="math/tex; mode=display">s_{k+1} = T(s_k,x_k(s_k))</script>或简写为 <script type="math/tex; mode=display">s_{k+1} = T(s_k,x_k)</script>状态转移律也称状态转移方程。</li><li><strong>指标函数</strong>。有 <strong>阶段</strong> 指标函数和 <strong>过程</strong> 指标函数之分。阶段指标函数是对应某一阶段状态和从该状态出发的一个阶段的决策的某种效益度量，用 $v_k(s_k,x_k)$ 表示。过程指标函数是指从状态 $s_k(k=1,\cdots ,n)$ 出发至过程最终，当采取某种子策略时，按预定标准得到的效益值。这个值既与 $s_k$ 的状态值有关，又与 $s_k$ 之后所选取的策略有关，它是两者的函数值，记作 <script type="math/tex; mode=display">V_{k,n}(s_k,x_k,s_{k+1},x_{k+1},\cdots ,s_n,x_n)</script>过程指标函数又是它所包含的各阶段指标函数的函数，按问题性质，它可以是各阶段指标函数的和、积或其他函数形式。当 $s_k$ 的值确定后，指标函数的值就只同 $k$ 阶段起的子策略有关。所谓最优指标函数，是指对某一确定状态选取最优策略吼得到的指标函数值，实际上也就是对应某一最优子策略的某种效益度量（这个度量值可以是产量、成本、距离等）。对应从状态 $s_k$ 出发的最优子策略的效益值记作 $f_k(s_k)$，于是有 <script type="math/tex; mode=display">f_k(s_k) = opt\ V_{k,n}</script>式中 $opt$ 表示最优化，根据效益值的具体含义可以是求最大 $(max)$ 或最小 $(min)$。</li></ol><h3 id="最优化原理与动态规划的数学模型"><a href="#最优化原理与动态规划的数学模型" class="headerlink" title="最优化原理与动态规划的数学模型"></a>最优化原理与动态规划的数学模型</h3><blockquote><p>动态规划最优化原理：<br>一个最优策略的子策略总是最优的。即无论过去的状态及决策如何，对前面决策所形成的状态而言，后面的决策必须构成最优策略。<br>因此，动态规划方法一般采用递推解法。</p></blockquote><h4 id="动态规划的基本方程"><a href="#动态规划的基本方程" class="headerlink" title="动态规划的基本方程"></a>动态规划的基本方程</h4><p>当 $\displaystyle V<em>{k,n} = \sum</em>{i=k}^{n}v_i(s_i,x_i)$ 时，有</p><script type="math/tex; mode=display">f_k(s_k) = \underset{x_k \in D_k(s_k)}{opt} \{ v_k(s_k,x_k) + f_{k+1}(s_{k+1}) \}</script><p>边界条件一般为 $f<em>{n+1}(s</em>{n+1}) = 0$ ;<br>当 $\displaystyle V<em>{k,n} = \prod</em>{i=k}^{n}v_i(s_i,x_i)$ 时，有</p><script type="math/tex; mode=display">f_k(s_k) = \underset{x_k \in D_k(s_k)}{opt} \{ v_k(s_k,x_k) \cdot f_{k+1}(s_{k+1}) \}</script><p>边界条件一般为 $f<em>{n+1}(s</em>{n+1}) = 1$ .</p><hr><p>…..不写了，摆烂了，这章送他</p>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图与网络分析</title>
      <link href="/posts/90012.html"/>
      <url>/posts/90012.html</url>
      
        <content type="html"><![CDATA[<h1 id="图与网络分析"><a href="#图与网络分析" class="headerlink" title="图与网络分析"></a>图与网络分析</h1><h2 id="图的基本概念与模型"><a href="#图的基本概念与模型" class="headerlink" title="图的基本概念与模型"></a>图的基本概念与模型</h2><p>P.S. 只列一些陌生概念（为什么图的概念会有这么多版本😅无语住了）</p><ul><li><strong>次</strong>：与某一个点 $v_i$ 相关联的边的数目称为点 $v_i$ 的次（degree），也叫做 <strong>度</strong>，记作 $d(v_i)$ </li><li><strong>部分图</strong>：$G_1 = \left{ V_1,E_1 \right}$，$G_2 = \left{ V_2,E_2 \right}$，若有 $V_1 =  V_2, E_1 \sqsubseteq E_2$，则称 $G_1$ 是 $G_2$ 的部分图。注意：部分图也是子图，子图不一定是部分图。（子图：$V_1 \sqsubseteq   V_2, E_1 \sqsubseteq E_2$）</li><li><strong>链、路</strong>：图中存在点和边交替序列 $\mu=\left{ v<em>0,e_1,v_1,\cdots ,e_k,v_k \right}$，若其中各边 $e_1,e_2,\cdots e_k$ 各不相同，且对任意的 $1\le t\le k$ 有，$v</em>{t-1}$ 和 $v_t$ 相邻，则称 $\mu$ 为 <strong>链</strong>。如果链中所有顶点 $v_0,v_1,\cdots v_k$ 也互不相同，则称这样的链为 <strong>路</strong>。</li></ul><hr><h2 id="树和图的最小部分树"><a href="#树和图的最小部分树" class="headerlink" title="树和图的最小部分树"></a>树和图的最小部分树</h2><p>最小部分树就是最小生成树</p><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ul><li>任何树中必定存在度为 <em>1</em> 的点</li><li>具有 <em>n</em> 个顶点的树的边树恰好等于 $(n-1)$</li><li>任何具有 <em>n</em> 个点、<em>(n-1)</em> 条边的连通图是树</li></ul><p>以上性质说明：</p><ul><li>树是无圈连通图中边数最多，即在树上只要任意再加上一条边就一定会出现圈。</li><li>由于树是无圈的连通图，<strong>即图的任意两个点之间有且仅有一条唯一通路</strong>。因此树也是最脆弱的连通图，只要从树中取走任意一条边，图就不连通了。因此一些重要的网络不能按照树的结构设计。</li></ul><h3 id="图的最小部分树"><a href="#图的最小部分树" class="headerlink" title="图的最小部分树"></a>图的最小部分树</h3><p><strong>定义</strong>：<br>如果 $G_1$ 是 $G_2$ 的部分图，同时又是树，则称 $G_1$ 是 $G_2$ 的部分树。在所有部分树中树枝总长度最小的部分树，称为该图的最小部分树（也称为最小支撑树）。</p><blockquote><p><strong>定理</strong>：<br>图中任意一点 <em>i</em>，若 <em>j</em> 是与 <em>i</em> 相邻点中距离最近的，则边 $[i,j]$ 一定&gt; 含在该图的最小部分树内。</p></blockquote><h3 id="避圈法和破圈法"><a href="#避圈法和破圈法" class="headerlink" title="避圈法和破圈法"></a>避圈法和破圈法</h3><p>两种方法寻找图的最小部分树</p><p>避圈法：</p><ol><li>从图中任选一点 $v_i$，使得 $v_i \in V$，图中其余点均包含在 $\overline{V}$ 中</li><li>从 $V、\overline{V}$ 的连线中找出最小边，这条边一定包含在最小部分树内。不妨设最小边为 $[v_i,v_j]$，将其加粗，用以标记该边是最小部分树内的边。</li><li>令 $V \cup v_i \implies V，\overline{V} \backslash v_i \implies \overline{V}$</li><li>重复 2、3 两步，直至图中所有点均包含在 <em>V</em> 中为止。</li></ol><p>破圈法：</p><ul><li>从网络图 <em>N</em> 中任意取一条回路</li><li>去掉这个回路中权数最大的一条边，得到一个子网络 $N_1$.</li><li>在 $N_1$ 中再任取一回路，再去掉回路中权数最大的一条边，得到 $N_2$</li><li>如此继续下去，一直到剩下的子图中不再含回路为止。得到的子图就是 <em>N</em> 的最小部分树。</li></ul><hr><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="Dijkstra-算法（求指定两点之间最短距离）"><a href="#Dijkstra-算法（求指定两点之间最短距离）" class="headerlink" title="Dijkstra 算法（求指定两点之间最短距离）"></a>Dijkstra 算法（求指定两点之间最短距离）</h3><p>用 $d<em>{ij}$ 表示图中两相邻点 $i$ 与 $j$ 的距离，若 $i$ 与 $j$ 不相邻，令 $d</em>{ij} = \infty$，显然 $d<em>{ii} = 0$，若用 $L</em>{si}$ 表示从 $s$ 点到 $i$ 点的最短距离，现要求从 $s$ 点到某一点 $t$ 的最短距离，用 $Dijkstra$ 算法步骤如下：</p><ol><li>从点 $s$ 出发，因为 $L_{ss} = 0$，将此值标注在 $s$ 旁的小方框内，表示 $s$ 点已标号；</li><li>从 $s$ 点出发，找出与 $s$ 相邻的点中距离最小的一个，设为 $r$，将 $L<em>{sr} = L</em>{ss} + d_{sr}$ 的值标注在 $r$ 旁的小方框内，表明点 $r$ 也已经标号；</li><li>从已标号的点出发，找出与这些点相邻的所有未标号的点 $p$，若有 $L<em>{sp} = \min(L</em>{ss}+d<em>{sp}; L</em>{sr} + d<em>{rp})$，则对 $p$ 点标号，并将 $L</em>{sp}$ 的值标注在 $p$ 点旁的小方框内；</li><li>重复前三步骤，一直到 $t$ 点得到标号为止</li></ol><h3 id="Floyd-算法（求任意两点之间的最短距离）"><a href="#Floyd-算法（求任意两点之间的最短距离）" class="headerlink" title="Floyd 算法（求任意两点之间的最短距离）"></a>Floyd 算法（求任意两点之间的最短距离）</h3><p>要点：以每一个顶点为中转站，刷新所有入度和出度的距离<br>因此需要：遍历每一个点顶点 —&gt; 遍历每一个顶点的入度 —&gt; 遍历每一个顶点的出度，以这个点为中转站，距离更短就刷新距离<br>核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="comment">//所有入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="comment">//所有出度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; graph[j].length; k++) &#123;</span><br><span class="line">                <span class="comment">//以每个点为「中转」，刷新所有出度和入度之间的距离</span></span><br><span class="line">                <span class="comment">//例如 AB + BC &lt; AC 就刷新距离</span></span><br><span class="line">                <span class="keyword">if</span> (graph[j][i] != -<span class="number">1</span> &amp;&amp; graph[i][k] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newDistance</span> <span class="operator">=</span> graph[j][i] + graph[i][k];</span><br><span class="line">                    <span class="keyword">if</span> (newDistance &lt; graph[j][k] || graph[j][k] == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//刷新距离</span></span><br><span class="line">                        graph[j][k] = newDistance;</span><br><span class="line">                        <span class="comment">//刷新路径</span></span><br><span class="line">                        path[j][k] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="网络的最大流"><a href="#网络的最大流" class="headerlink" title="网络的最大流"></a>网络的最大流</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><blockquote><p><strong>有向图与容量网络</strong><br>研究流量问题时候常常在有向图中进行。有向图上的有规定指向的连线称作 <strong>弧</strong>。弧的代号是 $(v<em>i,v_j)$， 有向图是点与弧的集合，记作 $D(V,A)$。<br>容量网络是指每条弧 $(v_i,v_j)$ 都给出一个最大的通过能力，称为该弧的容量，记为 $c(v_i,v_j)$ 或简写成 $c</em>{ij}$。容量网路中规定一个发点（也称为源点，记作 $s$）和一个收点（也称汇点，记作 $t$），其他点称为中间点。<br>网络的最大流是指网络中从发点到收点之间允许通过的最大流量</p><p><strong>流与可行流</strong><br>所谓流是指加在网络上各条弧上的一组负载量。对加在弧 $(v<em>i,v_j)$ 上的负载量记作 $f(v_i,v_j)$ 或简写成 $f</em>{ij}$。若网络上所有的 $f_{ij}=0$，这个流成为零流。<br>称在容量网络上满足条件 $(1. 1)、(1. 2)$ 的一组流为可行流</p><ol><li>容量限制条件，对所有弧有 <script type="math/tex; mode=display">0\le f(v_i,v_j) \le c(v_i,v_j)\tag{1. 1}</script></li><li>中间点平衡条件<script type="math/tex; mode=display">\sum_{}f(v_i,v_j) - \sum_{}f(v_j,v_i) = 0\quad (i \neq s,t) \tag{1. 2}</script>若以 $v(f)$ 表示网络中 $s\to t$ 的流量，则有<script type="math/tex; mode=display">v(f) = \sum_{j}f(v_s,v_j) + \sum_{j}f(v_j,v_t) \tag{1. 3}</script>任何网络一定存在可行流，因零流是可行流。求网络最大流是指，满足容量限制条件和中间点平衡条件下，使 $f(v)$ 值达到最大。</li></ol></blockquote><h3 id="割和流量"><a href="#割和流量" class="headerlink" title="割和流量"></a>割和流量</h3><p><strong>割</strong>是指将容量网络中的发点和收点分割开，并使 $s\to t$ 的流中断的一组弧的集合，</p><h3 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h3><p><strong>增广链</strong><br>如果在网络的发点和收点之间能找出一条链，在这条链上所有指向为 $s \to t$ 的弧（称 <strong>前向弧</strong>，记作 <strong>$\mu^{+}$</strong>），存在 $f<c$；所有指向为 $t \to s$ 的弧（称 **后向弧**，记作 **$\mu^{-}$**），存在 $f>0$，这样的链称 <strong>增广链</strong>。<br>当有增广链存在时找出</p><script type="math/tex; mode=display">\theta = \min \begin{cases}    (c_i-f_i),\quad \text{对} \mu^{+} \\    f_i\ ,\quad \quad \quad \ \ \text{对} \mu^{-}\end{cases}\qquad (\theta > 0)</script><p>再令</p><script type="math/tex; mode=display">f^{'} = \begin{cases}    f_i + \theta,\quad \text{对所有} \mu^{+} \\    f_i - \theta,\quad \text{对所有} \mu^{-} \\    f_i\ , \quad \quad\ \  \text{对非增广链上的弧}\end{cases}</script><p>显然 $f^{‘}$ 仍是一个可行流，但较之原来的可行流 $f$，这时网络中从 $s \to t$ 的流量增大了一个 $\theta$，因此 <strong>只有当网络图中找不到增广链时，$s \to t$ 的流才不可能进一步增大</strong>。</p><blockquote><p>定理：<br>在网络中 $s \to t$ 的最大流量等于它的最小割集的容量，即 </p><script type="math/tex; mode=display">v^{*}(f) = c^{*}(V,\overline{V})</script></blockquote><h3 id="求网络最大流的标号算法"><a href="#求网络最大流的标号算法" class="headerlink" title="求网络最大流的标号算法"></a>求网络最大流的标号算法</h3><p>又称 $Ford-Fulkerson$ 标号算法<br>算法实质是判断是否有增广链存在 并设法吧增广链找出来<br>标号算法步骤：</p><ol><li>首先给发点 $s$ 标号 $(0,\varepsilon(s))$。括弧中第一个数字是使这个点得到标号的前一个点的标号，因 $s$ 是发点，故记作 $0$；第二个数字 $\varepsilon(s)$ 表示从上一个标号点到这个标号点的流量最大允许调整值，$s$ 为发点，不限允许调整量，故 $\varepsilon(s) = \infty$。</li><li>列出与已标号点相邻的所有未标号点：<ol><li>考虑从标号点 $i$ 出发的弧 $(i,j)$，如果有 $f<em>{ij} = c</em>{ij}$，不给点 $j$ 标号；若有 $f<em>{ij} &lt; c</em>{ij}$，则对点 $j$ 标号，记为 $(i,\varepsilon(j))$，括弧中 $i$ 表示点 $j$ 的标号是从点 $i$ 延伸过来的，$\varepsilon(j) = min { \varepsilon(i),(c<em>{ij}-f</em>{ij})}$；</li><li>考虑所有指向标号点 $i$ 的弧 $(h,i)$，如果有 $f<em>{hi}=0$，对 $h$ 点不标号；若有 $f</em>{hi} &gt; 0$，则对点 $h$ 标号，记为 $(h,\varepsilon(h))$，其中，$\varepsilon(h) = min { \varepsilon(h),f_{hi}}$；</li><li>如果某为标号点 $k$ 有两个以上相邻的标号点，为了减少迭代次数，可按前两步中所述规则分别计算出 $\varepsilon(k)$ 的值，并取其中最大的一个标记。</li></ol></li><li>重复第2步，可能出现以下两种结局：<ul><li>标号过程中断，$t$ 得不到标号，说明该网络中不存在增广链，给定的流量即为最大流。记已标号点的集合为 $V$，未标号点集合为 $\overline{V}$，$(V,\overline{V})$，为网络的最小割；</li><li>$t$ 得到标号，这时可用反向追踪法在网络中找出一条从 $s \to t$ 的由标号点及相应的弧连接而成的增广链。</li></ul></li><li>修改流量，设图中原有可行流为 $f$，令 <script type="math/tex; mode=display">f^{'}=\begin{cases} f + \varepsilon(t),\quad \text{对增广链上所有前向弧} \\ f - \varepsilon(t),\quad \text{对增广链上所有后向弧} \\ f\ , \quad \quad \quad \ \ \text{对所有非增广链上的弧}\end{cases}</script>这样又得到网络上的一个新的可行流 $f^{‘}$.</li><li>抹掉图上所有标号，重复一至四步，直至图中找不到任何增广链，即出现第三步的第一个结局为止，这是网络图中的流量即为最大流。</li></ol><h2 id="最小费用流"><a href="#最小费用流" class="headerlink" title="最小费用流"></a>最小费用流</h2><p>最小费用流问题描述：<br>设网络有 $n$ 个点，$f<em>{ij}$ 为弧 $(i,j)$ 上的流量，$c</em>{ij}$ 为该弧的容量，$b<em>{ij}$ 为在弧 $(i,j)$ 上通过单位流量时的费用，$s_i$ 代表第 $i$ 点的可供量或需求量，当 $i$ 为发点时，$s_i&gt;0$，$i$ 为收点时，$s_i&lt;0$，$i$ 为中转点时，$s_i=0$。当网络供需平衡，即 $\displaystyle \sum</em>{i}s_i=0$ 时，将各发点物资调运到各收点（或从各发点按最大流量调运到各收点），使总掉运费用最小的问题，可归结为如下线性规划模型：</p><script type="math/tex; mode=display">min\ z = \sum_{i=1}^{n}\sum_{j=1}^{n}b_{ij}\,f_{ij} \\s.t. \begin{cases}    \displaystyle \sum_{j=1}^{n}f_{ij} - \sum_{k=1}^{n}f_{ki} = s_i(i=1,\cdots ,n) \\    0 \le f_{ij} \le c_{ij} (对弧(i,j)) \\\end{cases}</script><p>最小费用流问题解题步：</p><ol><li>从零流 $f_0$ 开始。$f_0$ 是可行流，也是相应的流量为零时费用最小的</li><li>对可行流 $f_k$ 构造加权网络 $W(f_k)$，方法是：<ol><li>对 $0&lt;f<em>{ij}&lt;c</em>{ij}$ 的弧 $(i,j)$，当其为正向弧时，通过单位流的费用为 $b<em>{ij}$，当其为反向弧时，相应费用 $b</em>{ji}=-b<em>{ij}$。故在 $i$ 和 $j$ 点之间分别给出弧 $(i,j)$ 和 $(j,i)$ ，其权数分别为 $b</em>{ij}$ 和 $-b_{ij}$。</li><li>对 $f<em>{ij}=c</em>{ij}$ 的弧 $(i,j)$，因为该弧流量已饱和，在增广链中只能作为反向弧。故在 $W(j<em>k)$ 中只画出弧 $(j,i)$，其权数值为 $-b</em>{ij}$。</li><li>对 $f<em>{ij} = 0$ 的弧 $(i,j)$，在增广链中只能为正向弧，故在 $W(j_k)$ 中只画出弧 $(i,j)$，其权数值为 $b</em>{ij}$。</li></ol></li><li>在加权网络 $W(f<em>k)$ 中，寻找费用最小的增广链，也即求从 $s \to t$ 的最短路，并将该增广链上流量调整至允许的最大值，得到一个新的流量 $f</em>{k+1}(&gt;f_k)$。</li><li>重复第二、三两步，直至网络 $W(f<em>{k+m})$ 中找不到增广链（也即找不出最短路）时，$f</em>{k+}$ 即为要寻找的最小费用流。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析公式速记</title>
      <link href="/posts/16515.html"/>
      <url>/posts/16515.html</url>
      
        <content type="html"><![CDATA[<h1 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a>数值分析</h1><p>考试迫使记的<span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span> 都是公式而已，没有公式说明,没有推导过程，懂自懂</p><h1 id="1、误差"><a href="#1、误差" class="headerlink" title="1、误差"></a>1、误差</h1><ul><li>$x^{*}$ 为 $x$ 一个近似值</li><li>绝对误差：$e^{<em>} = x^{</em>} - x$</li><li>相对误差：$\displaystyle e_r^{<em>} = \frac{e^{</em>}}{x} = \frac{x^{<em>} - x}{x}$，由于真值 $x$ 总是不知道的，通常取 $\displaystyle e_r^{</em>} = \frac{e^{<em>}}{x^{</em>}} = \frac{x^{<em>} - x}{x^{</em>}}$</li><li>误差限：$|x^{<em>} - x| \le \varepsilon^{</em>}$</li><li>相对误差限：$\varepsilon_r^{<em>} = \displaystyle \frac{\varepsilon^{</em>}}{|x^{*}|}$</li><li>$\varepsilon(f(x^{<em>})) \approx |f^{‘}(x^{</em>})|\varepsilon(x^{*})$</li></ul><h1 id="2、插值法"><a href="#2、插值法" class="headerlink" title="2、插值法"></a>2、插值法</h1><ul><li>记 $\omega<em>{n+1}(x) = (x-x</em>{0})(x-x_1)\cdots (x-x_n)$</li><li>$Lagrange$ 插值多项式系数：<script type="math/tex; mode=display">l_k(x_k) = \displaystyle \frac{(x-x_0)\cdots (x-x_{k-1})(x-x_{k+1})\cdots (x-x_n)}{(x_k-x_0)\cdots (x_k-x_{k-1})(x-x_{k+1})\cdots (x-x_n)}</script></li><li>$Lagrange$ 插值多项式：<script type="math/tex; mode=display">L_n(x) = \displaystyle \sum_{k=0}^{n} l_k(x)y_k = \sum_{k=0}^{n} y_k \frac{\omega_{n+1}(x)}{\omega^{'}_{n+1}(x_k)(x-x_k)}</script></li><li>余项：记 $M<em>{n+1} =\displaystyle  \max</em>{a\le x\le b}|f^{n+1}(x)|$ <script type="math/tex; mode=display">\displaystyle R(x) = \frac{f^{n+1}(\xi)\omega_{n+1}(x)}{(n+1)!} \le \frac{M_{n+1}}{(n+1)!}|\omega_{n+1}(x)|</script></li></ul><h2 id="均差与-NewTon-插值多项式"><a href="#均差与-NewTon-插值多项式" class="headerlink" title="均差与 NewTon 插值多项式"></a>均差与 <em>NewTon</em> 插值多项式</h2><ul><li>一阶均差：$\displaystyle f[x_0, x_k] = \frac{f(x_k) - f(x_0)}{x_k-x_0}$</li><li>$k$ 阶均差：<script type="math/tex; mode=display">f[x_0,x_1,\cdots ,x_k] = \frac{f[x_0,\cdots ,x_{k-2},x_k] - f[x_0,\cdots ,x_{k-2},x_{k-1}]}{x_k - x_{k-1}}</script></li><li>$\displaystyle f[x_0,x_1,\cdots ,x_n] = \frac{f^{(n)}(\xi)}{n!} \qquad (x_0,x_1,\cdots ,x_n,\xi \in [a,b])$</li><li>$\displaystyle f[x<em>0,x_1,\cdots ,x_k] = \sum</em>{j=0}^{k}\frac{f(x<em>j)}{\omega</em>{k+1}^{‘}(x_j)}$</li><li>$NewTon$ 插值多项式：<script type="math/tex; mode=display">P_n(x) = f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)+\cdots \\ +f[x_0,x_1,\cdots ,x_n](x-x_0)(x-x_1)\cdots (x-x_{n-1})</script></li><li>余项：$R(x) = f[x<em>0,x_1,\cdots ,x_n]\omega</em>{n+1}(x)$</li></ul><h2 id="Hermite-插值"><a href="#Hermite-插值" class="headerlink" title="Hermite 插值"></a><em>Hermite</em> 插值</h2><ul><li>$Taylor$ 多项式：<script type="math/tex; mode=display">\displaystyle P_n(x) = f(x_0) + f^{'}(x_0)(x-x_0) + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^{n}</script><ul><li>余项：$\displaystyle R(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}$</li></ul></li><li>若已知 $f(x_0),f^{‘}(x_1),f(x_1),f(x_2)$：<script type="math/tex; mode=display">P(x) = f(x_0) + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) \\ + A(x-x_0)(x-x_1)(x-x_2)</script>其中 $A$ 由 $P^{‘}(x_1) = f^{‘}(x_1)$ 可得<ul><li>余项：<script type="math/tex; mode=display">R(x) = \frac{1}{4!}f^{(4)}(\xi)(x-x_0)(x-x_1)^{2}(x-x_2)</script></li></ul></li><li>两点三次 $Hermite$ 插值多项式：<script type="math/tex; mode=display">H_3(x) = \alpha_k(x)y_k + \alpha_{k+1}(x)y_{k+1} + \beta_k(x)m_k + \beta_{k+1}(x)m_{k+1}</script>其中 $m<em>k = f^{‘}(x_k), m</em>{k+1} = f^{‘}(x_{k+1})$<script type="math/tex; mode=display">\begin{cases}\displaystyle   \alpha_k(x) = (1+2\frac{x-x_k}{x_{k+1}-x_k})(\frac{x-x_{k+1}}{x_k-x_{k+1}})^{2} \\\\ \displaystyle  \alpha_{k+1}(x) = (1+2\frac{x-x_{k+1}}{x_k-x_{k+1}})(\frac{x-x_k}{x_{k+1}-x_k})^{2} \\\end{cases}</script><script type="math/tex; mode=display">\begin{cases}\displaystyle   \beta_k(x) = (x-x_k)(\frac{x-x_{k+1}}{x_k-x_{k+1}})^{2} \\\\ \displaystyle   \beta_{k+1}(x) = (x-x_{k+1})(\frac{x-x_k}{x_{k+1}-x_k})^{2} \\\end{cases}</script><ul><li>余项：<script type="math/tex; mode=display">\displaystyle R(x) = \frac{f^{(4)}(\xi)}{4!}(x-x_k)^{2}(x-x_{k+1})^{2}</script></li></ul></li></ul><h2 id="分段低次插值"><a href="#分段低次插值" class="headerlink" title="分段低次插值"></a>分段低次插值</h2><ul><li>$\displaystyle h = \frac{b-a}{n}$</li><li>对每个小区间使用对应插值公式求 $I_h(x)$</li><li>余项<ul><li>对分段线性插值函数：<script type="math/tex; mode=display">\max_{a\le x\le b}|f(x) - I_h(x)| \le \frac{M_2}{8}h^{2}</script></li><li>对分段三次埃尔米特插值：<script type="math/tex; mode=display">\max_{a\le x\le b}|f(x) - I_h(x)| \le \frac{M_4}{384}h^{4}</script></li></ul></li></ul><h1 id="3、数值积分"><a href="#3、数值积分" class="headerlink" title="3、数值积分"></a>3、数值积分</h1><h2 id="代数精度"><a href="#代数精度" class="headerlink" title="代数精度"></a>代数精度</h2><p>定义：</p><ul><li>如果某个求积公式对于次数不超过 $m$ 的多项式均能够准确成立，但对于 $m+1$ 次多项式就不准确成立，则称该公式具有 <strong>$m$ 次代数精度</strong></li></ul><h2 id="梯形公式公式与中矩形公式"><a href="#梯形公式公式与中矩形公式" class="headerlink" title="梯形公式公式与中矩形公式"></a>梯形公式公式与中矩形公式</h2><ul><li>梯形公式：<script type="math/tex; mode=display">\displaystyle \int_{a}^{b}f(x)dx \approx \frac{b-a}{2}f(a) + \frac{b-a}{2}f(b)</script><ul><li>余项：<script type="math/tex; mode=display">\displaystyle R[f] = -\frac{(b-a)^{3}}{12}f^{''}(\eta)\qquad (\eta \in (a,b))</script></li></ul></li><li>矩形公式：<script type="math/tex; mode=display">\displaystyle \int_{a}^{b}f(x)dx \approx (b-a)f(\frac{a+b}{2})</script><ul><li>余项：<script type="math/tex; mode=display">\displaystyle R[f] = \frac{(b-a)^{3}}{24}f^{''}(\eta)\qquad (\eta \in (a,b))</script></li></ul></li></ul><h2 id="Newton-Cotes-公式"><a href="#Newton-Cotes-公式" class="headerlink" title="Newton-Cotes 公式"></a><em>Newton-Cotes</em> 公式</h2><p>将积分区间 $[a,b]$ 分成 $n$ 等分</p><ul><li>$Simpson$ 公式（$n=2$）：<script type="math/tex; mode=display">\displaystyle \int_{a}^{b}f(x)dx \approx \frac{b-a}{6}f(a) + \frac{b-a}{6}f(b) + \frac{2(b-a)}{3}f(\frac{a+b}{2})</script><ul><li>余项：<script type="math/tex; mode=display">R[f] = -\frac{(b-a)^{5}}{180*2^{4}}f^{(4)}(\eta)\qquad (\eta \in (a,b))</script></li></ul></li><li>$Cotes$ 公式（$n=4$）：<script type="math/tex; mode=display">C = \frac{b-a}{90}[7f(x_0)+32f(x_1)+12f(x_2)+32f(x_3)+7f(x_4)]</script><ul><li>余项：<script type="math/tex; mode=display">R[f] = -\frac{2(b-a)^{7}}{945*4^{6}}f^{(6)}(\eta)\qquad (\eta \in (a,b))</script></li></ul></li></ul><h2 id="复合求积公式"><a href="#复合求积公式" class="headerlink" title="复合求积公式"></a>复合求积公式</h2><p>积分区间 $[a,b]$ 分成 $n$ 等分，步长 $\displaystyle h = \frac{b-a}{n}$</p><ul><li>复合梯形公式：<script type="math/tex; mode=display">T_n = \frac{h}{2}[f(a)+2\sum_{k=1}^{n-1}f(x_k)+f(b)]</script><ul><li>余项：<script type="math/tex; mode=display">R_n(f) = -\frac{b-a}{12}h^{2}f^{''}(\eta)</script></li></ul></li><li>复合 $Simpson$ 求积公式：<script type="math/tex; mode=display">S_n = \frac{h}{6}[f(a)+2\sum_{k=1}^{n-1}f(x_k)+4\sum_{k=0}^{n-1}f(x_{(k+1)/2})+f(b)]</script>其中 $\displaystyle x_{(k+1)/2} = x_k+\frac{h}{2}$<ul><li>余项：<script type="math/tex; mode=display">R_n(f) = -\frac{b-a}{180}(\frac{h}{2})^{4}f^{(4)}(\eta)</script></li></ul></li></ul><h2 id="龙贝格求积算法"><a href="#龙贝格求积算法" class="headerlink" title="龙贝格求积算法"></a>龙贝格求积算法</h2><ul><li>$T_0^{(0)} = \displaystyle \frac{h}{2}[f(a)+f(b)]$</li><li>求梯形值 $\displaystyle T_0(\frac{b-a}{2^{k}})$，利用递推公式求 $T_0^{(k)}$，递推公式：<script type="math/tex; mode=display">\displaystyle T_{2n} = \frac{1}{2}T_n + \frac{h}{2}\sum_{k=0}^{n-1}f(x_{k+\frac{1}{2}})</script></li><li>求加速值：<script type="math/tex; mode=display">T_m^{(k)} = \frac{4^{m}}{4^{m}-1}T_{m-1}^{k+1} - \frac{1}{4^{m}-1}T_{m-1}^{(k)} \qquad k = 1,2,\cdots</script></li></ul><h2 id="高斯-勒让德求积公式"><a href="#高斯-勒让德求积公式" class="headerlink" title="高斯-勒让德求积公式"></a>高斯-勒让德求积公式</h2><ul><li>积分区间为 $[-1,1]$</li><li>$\displaystyle \int<em>{-1}^{1}f(x)dx \approx \sum</em>{k=0}^{n}A_kf(x_k)$</li><li>余项：$n=1$ 时，$\displaystyle R_1[f] = \frac{1}{135}f^{(4)}(\eta)$</li></ul><h1 id="4、解线性方程组的直接方法"><a href="#4、解线性方程组的直接方法" class="headerlink" title="4、解线性方程组的直接方法"></a>4、解线性方程组的直接方法</h1><h2 id="列主元高斯消去法"><a href="#列主元高斯消去法" class="headerlink" title="列主元高斯消去法"></a>列主元高斯消去法</h2><ul><li>在每次消元时，选取列主元在最前面，列主元为该列最大值</li></ul><h2 id="矩阵三角分解法"><a href="#矩阵三角分解法" class="headerlink" title="矩阵三角分解法"></a>矩阵三角分解法</h2><ul><li>如果 $n$ 阶矩阵 $A$ 的各阶顺序主子式 $D_k \left( k = 1,2,\cdots ,n-1 \right)$ 均不为零，则必有单位下三角矩阵 $L$ 和上三角矩阵 $U$，使得 $A = LU$，并且 $L$ 和 $U$ 是唯一的。</li><li>对矩阵进行 $LU$ 分解后（杜利特尔分解）<ul><li>解 $Ly = b$ 得到 $y$</li><li>解 $Ux = y$ 得到 $x$</li></ul></li></ul><h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><ul><li>行范数：$\displaystyle ||A||<em>{\infty} = \max</em>{1 \le i \le n}\sum<em>{j=1}^{n}|a</em>{ij}|$</li><li>列范数：$\displaystyle ||A||<em>{1} = \max</em>{1 \le j \le n}\sum<em>{i=1}^{n}|a</em>{ij}|$</li><li>2- 范数：$\displaystyle ||A||<em>{2} = \sqrt{\lambda</em>{max}(A^{T}A)}$ ，其中 $\lambda_{max}(A^{T}A)$ 表示 $A^{T}A$ 的最大特征值<ul><li>特征值计算：$|\lambda E - A| = 0$，解得 $\lambda$ 即为 $A$ 的特征值</li></ul></li><li>F- 范数：$\displaystyle ||A||<em>F = \sqrt{\sum</em>{i=1,j=1}^{n}(a_{ij})^{2}}$</li></ul><h2 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h2><ul><li>$cond(A)<em>{\infty} = ||A^{-1}||</em>{\infty}||A||_{\infty}$</li><li>$A$ 的谱条件数 <script type="math/tex; mode=display">cond(A)_{2} = ||A||_2||A^{-1}||_2 = \sqrt{\frac{\lambda_{max}(A^{T}A)}{\lambda_{min}(A^{T}A)}}</script><ul><li>当 $A$ 为对称矩阵时，<script type="math/tex; mode=display">cond(A)_2 = \frac{|\lambda_1|}{|\lambda_n|}</script>其中，$\lambda_1$ 和 $\lambda_n$ 分别代表 $A$ 绝对值最大和绝对值最小的特征值</li></ul></li></ul><h1 id="5、解线性方程组的迭代方法"><a href="#5、解线性方程组的迭代方法" class="headerlink" title="5、解线性方程组的迭代方法"></a>5、解线性方程组的迭代方法</h1><ul><li>$Jacobi$ 迭代 <script type="math/tex; mode=display">\begin{cases}\displaystyle x_1^{(k+1)} = \frac{1}{a_{11}}(-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}\cdots -a_{1n}x_n^{(k)}+b_1) \\\\ \displaystyle x_2^{(k+1)} = \frac{1}{a_{22}}(-a_{21}x_1^{(k)}-a_{23}x_3^{(k)}\cdots -a_{2n}x_n^{(k)}+b_2) \\\cdots \\\displaystyle x_n^{(k+1)} = \frac{1}{a_{nn}}(-a_{n1}x_1^{(k)}-a_{n2}x_2^{(k)}\cdots -a_{n(n-1)}x_{n-1}^{(k)}+b_n) \\\end{cases}</script></li><li>$Gauss-Seidel$ 迭代<script type="math/tex; mode=display">\begin{cases}\displaystyle x_1^{(k+1)} = \frac{1}{a_{11}}(-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}\cdots -a_{1n}x_n^{(k)}+b_1) \\\\ \displaystyle x_2^{(k+1)} = \frac{1}{a_{22}}(-a_{21}x_1^{(k+1)}-a_{23}x_3^{(k)}\cdots -a_{2n}x_n^{(k)}+b_2) \\\cdots \\\displaystyle x_n^{(k+1)} = \frac{1}{a_{nn}}(-a_{n1}x_1^{(k+1)}-a_{n2}x_2^{(k+1)}\cdots -a_{n(n-1)}x_{n-1}^{(k+1)}+b_n) \\\end{cases}</script></li><li>收敛性：<ul><li>若 $A$ 严格对角占有，即 $\displaystyle |a<em>{ii}| &gt; \sum</em>{j=0}^{i-1}|a<em>{ij}| + \sum</em>{j=i+1}^{n}|a_{ij}|$，则两种迭代方法均收敛</li><li>迭代法 $x^{(k+1)} = Bx^{(k)}+f$ 对任意 $x^{(0)}$ 和 $f$ 均收敛的充要条件为 $\rho(B) &lt; 1$。其中 $B$ 为迭代矩阵，谱半径 $\rho(B)$ 为矩阵 $B$ 特征值的模的最大值。</li><li>矩阵的谱半径越小，收敛速度越快</li></ul></li></ul><h1 id="6、非线性方程和方程组的数值解法"><a href="#6、非线性方程和方程组的数值解法" class="headerlink" title="6、非线性方程和方程组的数值解法"></a>6、非线性方程和方程组的数值解法</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>计算步骤：</p><ol><li><strong>准备</strong>：计算 $f(x)$ 在有根区间 $[a,b]$ 端点处的值 $f(a),f(b)$</li><li><strong>二分</strong>：计算 $f(x)$ 在区间中点 $\displaystyle \frac{a+b}{2}$ 处的值 $\displaystyle f(\frac{a+b}{2})$</li><li><strong>判断</strong>：若 $\displaystyle f(\frac{a+b}{2}) = 0$，则 $\displaystyle x = \frac{a+b}{2}$ 即为方程的根，计算过程结束，否则检验：若 $\displaystyle f(\frac{a+b}{2})f(a) &lt; 0$，则 $\displaystyle b = \frac{a+b}{2}$，否则 $\displaystyle a = \frac{a+b}{2}$</li><li>反复执行步骤 2-3，直到区间 $[a,b]$ 的长度小于允许误差 $\varepsilon$，此时区间中点 $\displaystyle \frac{a+b}{2}$ 即为所求近似根</li></ol><p>二分法总是收敛的</p><h2 id="不动点迭代"><a href="#不动点迭代" class="headerlink" title="不动点迭代"></a>不动点迭代</h2><p>计算步骤：</p><ul><li>将方程 $f(x)=0$ 转换为 $x=\varphi(x)$</li><li>要求 $x^{<em>}$ 满足 $f(x^{</em>})=0$，则 $x^{<em>} = \varphi(x^{</em>})$，称 $x^{*}$ 为函数 $\varphi(x)$ 的一个不动点</li><li>选择一个初始近似值 $x_0$，将其代入 $x = \varphi(x)$ 式的右端可求得 $x_1 = \varphi(x_0)$</li><li>如上迭代计算 $x_{k+1} = \varphi(x_k)$，$\varphi(x)$ 称为迭代函数</li></ul><p>收敛性：</p><ul><li>若 $x^{<em>}$ 为 $\varphi(x)$ 的不动点，$\varphi(x)$ 在 $x^{</em>}$ 某领域内有连续导数，且 $\varphi(x^{*}) &lt; 1$，则该迭代法是局部收敛的。</li></ul><p>收敛阶：</p><ul><li>若迭代函数 $x=\varphi(x)$ 的根 $x^{*}$ 邻近具有 $p$ 阶连续导数，并且有 <script type="math/tex; mode=display">\varphi^{'}(x^{*}) = \varphi^{''}(x^{*}) = \cdots =\varphi^{(p-1)}(x^{*}) ,\ \varphi^{(p)}(x^{*}) \neq 0</script>那么迭代过程在 $x^{*}$ 附近是 $p$ 阶收敛的<ul><li>若 $0&lt;\varphi^{‘}(x^{<em>})&lt;1$，则迭代法 <em>*线性收敛</em></em></li><li>若 $\varphi^{‘}(x^{<em>})=0,\ \varphi^{‘’}(x^{</em>}) \neq 0$，则迭代法 <strong>平方收敛</strong></li></ul></li></ul><h2 id="Newton-法"><a href="#Newton-法" class="headerlink" title="Newton 法"></a><em>Newton</em> 法</h2><ul><li>$Newton$ 迭代法的构造：<script type="math/tex; mode=display">x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}</script></li><li>牛顿法是 <strong>平方收敛</strong> 的</li></ul><h3 id="简化牛顿法"><a href="#简化牛顿法" class="headerlink" title="简化牛顿法"></a>简化牛顿法</h3><p>构造迭代公式：</p><script type="math/tex; mode=display">x_{k+1} = x_k-\frac{f(x_k)}{f^{'}(x_0)}</script><p>只有一阶收敛</p><h3 id="牛顿下山法"><a href="#牛顿下山法" class="headerlink" title="牛顿下山法"></a>牛顿下山法</h3><p>构造迭代公式：</p><script type="math/tex; mode=display">x_{k+1} = x_k - \lambda \frac{f(x_k)}{f^{'}(x_k)}</script><p>可以通过选取 $\lambda$ 值使得 $|f(x<em>k)| &gt; |f(x</em>{k+1})|$，通常先令 $\lambda=1$，若上式子不成立则 $\lambda$ 减半，直到上式成立</p><h3 id="重根情况"><a href="#重根情况" class="headerlink" title="重根情况"></a>重根情况</h3><p>若 $f(x) = (x-x^{<em>})^{m}g(x)$，即 $x^{</em>}$ 为方程 $m$ 重根，在无需提前知道 $m$ 取值的情况下，可构造平方收敛的 迭代公式</p><script type="math/tex; mode=display">x_{k+1} = x_k - \frac{f(x_k)f^{'}(x_k)}{[f^{'}(x_k)]^{2}-f(x_k)f^{''}(x_k)}</script>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 数值分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考试！考试！考试！😫 </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标规划</title>
      <link href="/posts/68613.html"/>
      <url>/posts/68613.html</url>
      
        <content type="html"><![CDATA[<h1 id="目标规划"><a href="#目标规划" class="headerlink" title="目标规划"></a>目标规划</h1><p>重点掌握目标规划模型的建立</p><h2 id="目标规划问题的提出"><a href="#目标规划问题的提出" class="headerlink" title="目标规划问题的提出"></a>目标规划问题的提出</h2><p>线性规划在处理实际问题时的局限性</p><ul><li>线性规划只能处理单目标的优化问题，无法处理存在多个目标，特别时目标间无法用 <strong>同一量纲</strong> 来度量的情况</li><li>线性规划模型中的 <strong>约束是刚性、绝对的</strong>，稍有超差就可能导致问题无解</li><li>实际问题目标和约束可以 <strong>互相转化</strong>，但线性规划模型中将两者截然分开</li><li>线性规划追求最优解，而实际问题中往往得到满意解即可</li></ul><p>目标规划通过以下途径来解决上述线性规划建模中的局限性：</p><ol><li>设置 <strong>偏差常量</strong>，用来表明实际值同目标值之间的差异，偏差变量用下列符号表示：<ul><li>$d^{+}$：超出目标的差值，称为 <strong>正偏差变量</strong></li><li>$d^{-}$：未达到目标的差值，称为 <strong>负偏差变量</strong><br>两种偏差常量中必至少定有一个为零</li></ul></li><li>统一处理目标和约束：<ul><li>只对资源使用上有 <strong>严格限制</strong> 的建立 <strong>系统（刚性）约束</strong>。数学形式上为严格的 <strong>等式或不等式</strong>，同线性规划中的约束条件。</li><li>对那些不严格限定的约束，<strong>连同原线性规划建模时的目标</strong>，均通过<strong>目标约束来</strong>表达。目标约束是一种将约束同目标结合在一起的表达式。</li></ul></li><li>目标的优先级与权系数：<br>在一个目标规划的模型中，如果两个不同目标 <strong>重要程度</strong> 的相差悬殊，为了达到某一目标可以牺牲一些次要目标，称这些目标是属于 <strong>不同层次的优先级</strong>。优先级层次的高低可分别通过 <strong>优先因子</strong> $P<em>1,P_2,\cdots$ 表示，并规定 $P_k \gg P</em>{k+1}$，即 <strong>不同优先级之间的差别无法用数字大小衡量</strong>，对属于 <strong>同一层次优先级的不同目标</strong>，按其 <strong>重要程度</strong> 可分别乘上不同的 <strong>权系数</strong>，权系数是一个具体数字，权系数越大，表明该目标越重要。</li></ol><p>目标规划的一般数学模型：</p><script type="math/tex; mode=display">\qquad \qquad \min_{} z=\sum_{k=1}^{K}P_k\sum_{l=1}^{L}(\ w^{-}_{kl}d_l^{-}\ +\ w^{+}_{kl}d_l^{+}\ ) \qquad \qquad (5.1a)\\s.t. \begin{cases}    \displaystyle \sum_{j=1}^{n}a_{ij}x_j\ \le\ (=,\ge )\ b_i\quad (i=1,2,\cdots,m) \qquad \qquad(5.1b)\\    \displaystyle \sum_{j=1}^{n}c_{lj}x_j+d_j^{-}-d_l^{+}=g_l \quad (l=1,2,\cdots,L) \qquad \quad\ (5.1c)\\    x_j \ge 0\qquad (j=1,2,\cdots,n)\\    d_l^{-},d_l^{+} \ge 0\qquad (l=1,2,\cdots,L)\end{cases}</script><p>式中：</p><ul><li>$P_m$为第k级优先因子，$k=1,2,\cdots,K$；</li><li>$w^{-}<em>{kl},w^{+}</em>{kl}$为分别赋予第 <em>l</em> 个目标约束的正负偏差变量的权系数；</li><li>$g_l$为第 <em>l</em> 个目标的预期目标值，$l=1,2,\cdots,L$；</li><li>$(5.1b)$ 为系统约束， $(5.1c)$ 为目标约束</li></ul><p>目标规划与线性规划模型的差异：</p><table  border="1" style="margin: auto；" width='80%'>    <tr>        <td></td>        <td style="text-align:center"><b>线性规划模型</b></td>        <td style="text-align:center"><b>目标规划模型</b></td>    </tr>    <tr>        <td style="text-align:center">变量</td>        <td style="text-align:center">只含决策变量</td>        <td style="text-align:center">分决策变量与偏差变量</td>    </tr>    <tr>        <td style="text-align:center">约束条件</td>        <td style="text-align:center">系统（刚性）约束</td>        <td style="text-align:center">分系统约束和目标约束</td>    </tr>    <tr>        <td style="text-align:center">目标函数</td>        <td style="text-align:center">为决策变量的函数</td>        <td style="text-align:center">为偏差变量的函数，并按优先级、权系数区分重要程度</td>    </tr>    <tr>        <td style="text-align:center">求解结果</td>        <td style="text-align:center">寻找最优解（有可能无可行解）</td>        <td style="text-align:center">寻找满意解</td>    </tr></table><h2 id="目标规划的图解分析法"><a href="#目标规划的图解分析法" class="headerlink" title="目标规划的图解分析法"></a>目标规划的图解分析法</h2><p>对模型中只含有两个变量（偏差变量不计入的目标规划问题），可以用图解分析的方法找到满意解。</p><ul><li>建立平面直角坐标系，确定坐标上的单位长度</li><li>将代表各目标约束的直线方程分别标示在坐标平面内</li><li>再按目标函数中目标的优先级分别依次分析</li></ul><h2 id="单纯形法求解目标规划"><a href="#单纯形法求解目标规划" class="headerlink" title="单纯形法求解目标规划"></a>单纯形法求解目标规划</h2><p>目标规划与线性规划的数学模型基本相同，所以用单纯形法求解是的方法步骤也基本相同。但由于目标规划中目标函数分不同优先级，因此应首先寻求使最高优先级的目标优化，然后再转向下一级当下一级目标优化后再专职更低一级，以此类推。</p><p>说明：</p><ul><li>对目标函数的优化是按优先级顺序逐级进行的，当$P_1$行的所有检验数均为非负时，说明第一行已经得到优化，可以转入下一级，在考察$P_2$行的检验数是否存在负值。以此类推。</li><li>当考察$P_2$行以下的检验数时，注意应 <strong>包括更高级别的优先因子在内</strong>。判断迭代计算能否停止的准则为：<ul><li>检验数 $P_1,P_2,\cdots,P_k$ 行的 <strong>所有值</strong>均为非负</li><li>若 $P<em>1,P_2,\cdots,P_i$ 行所有检验数为非负，第 $P</em>{i+1}$ 行存在负检验数，但在负检验数所在列的上面行中有正检验数。即从 $P_2$ 行开始，虽然在某一行存在负检验数，而该负检验数同列较高优先级的行中存在正检验数时，计算就该停止。</li></ul></li></ul><h2 id="求解目标规划的层次算法"><a href="#求解目标规划的层次算法" class="headerlink" title="求解目标规划的层次算法"></a>求解目标规划的层次算法</h2><p>根据目标规划求解思路是从搞优先级到低优先级逐层优化的原则，为保证较低层级优化在较高层级优化范围内进行，可将上一层次目标的优化值作为约束，加到下一层次的模型中。</p>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数规划</title>
      <link href="/posts/68621.html"/>
      <url>/posts/68621.html</url>
      
        <content type="html"><![CDATA[<h1 id="整数规划与分配问题"><a href="#整数规划与分配问题" class="headerlink" title="整数规划与分配问题"></a>整数规划与分配问题</h1><h2 id="整数规划问题的提出"><a href="#整数规划问题的提出" class="headerlink" title="整数规划问题的提出"></a>整数规划问题的提出</h2><p>所谓整数规划：<br><strong>决策变量要求取整数</strong>的线性规划</p><p>整数规划数学模型：</p><script type="math/tex; mode=display">\max_{}(\min_{}) z = \sum_{j=1}^{n}s_j x_j \\s.t. \begin{cases}    \displaystyle \sum a_{ij}x_j \le b_i \quad (i=1,2,\cdots,m) \\    x_j \ge 0\ 且全部或部分是整数\end{cases}</script><p>整数规划问题可以分为以下几种类型：</p><ul><li><strong>纯整数线性规划</strong>：全部决策变量都必须取整数的整数线性规划</li><li><strong>混合整数规划</strong>：只要求一部分决策变量取数值</li><li><strong>0-1整数规划</strong>：要求决策变量取值只能为0或1</li></ul><h2 id="分枝定界法"><a href="#分枝定界法" class="headerlink" title="分枝定界法"></a>分枝定界法</h2><p>分枝定界法是一种隐藏枚举法或部分枚举法，是在枚举法的基础上改进的</p><p>原问题的 <strong>松弛问题</strong> ：<br>任何整数规划，凡是放弃某些约束条件（如整数要求）后，所得到的新问题，称为原问题的松弛问题</p><h3 id="分枝定界法解题步骤"><a href="#分枝定界法解题步骤" class="headerlink" title="分枝定界法解题步骤"></a>分枝定界法解题步骤</h3><ol><li>寻找替代问题并求解<ul><li>放宽或取消原问题的某些约束条件，找出一个替代问题</li><li>替代问题要求：容易求解，<strong>且原问题的解集应无一例外地包含在替代问题地解集中</strong></li><li>若替代问题无可行解，则原线性规划问题无可行解</li><li>如果替代问题的 <strong>最优解</strong> 是原问题的 <strong>可行解</strong>，这个解就是原问题的最优解</li><li>否则这个解的值是原问题最优解的 <strong>上界</strong>（求极大值时）或 <strong>下界</strong>（求极小值时）</li></ul></li><li><strong>分枝与定界</strong><ul><li>将替代问题分成若干个子问题，对子问题也要求容易求解，且各子问题的解集要包含原问题的解集，对每个问题求最优解</li><li>若该解满足原问题的约束，即找到了一个原问题的 <strong>可行解</strong></li><li>否则该解为所属分枝的边界值（极大极小问题对应上下界）</li><li>如果所有子问题的最优解均非原问题的 <strong>可行解</strong>，则选取其上界最大（求极大值时）或下界最小（求极小值时）的子问题进一步在细分子问题求解。</li><li>重复分枝过程，直至找到一个找到一个原问题的可行解为止。</li><li>若计算过程中同时出现两个及以上的可行解，则选取其中上界最大（求极大值时）或下界最小（求极小值时）的一个保留</li></ul></li><li>剪枝<ul><li>将各子问题边界值与保留的可行解的值进行比较，把边界值劣于可行解的分枝剪去</li><li>如果除了保留下的可行解外，其余分枝均被剪去，则该可行解就是原问题的最优解</li><li>否则，回到分枝与定界，选取边界值最有的一个继续分枝。如果计算过程中又出现新的可行解时，则与原可行解进行比较，保留最优的，并重复上述步骤。</li></ul></li></ol><h2 id="割平面法"><a href="#割平面法" class="headerlink" title="割平面法"></a>割平面法</h2><p>基本思想：</p><blockquote><p>在整数规划问题的松弛问题中依次引进线性约束条件（称为割平面），使得问题的可行域逐步缩小。但每次切割只割去问题的部分非整数解，直到问题的目标函数值达到最优的整数点成为缩小后可行域的一个顶点，这样就可以用求解线性规划问题的方法找出这个最优解</p></blockquote><h3 id="割平面法解题思路"><a href="#割平面法解题思路" class="headerlink" title="割平面法解题思路;"></a>割平面法解题思路;</h3><ul><li>不考虑问题中变量的 <strong>整数约束条件</strong>，得到原问题松弛条件并求解，若该最优解满足整数条件，则该解就是原问题最优解</li><li>若松弛问题的最优解不满足整数条件，则从该解的非整分量中选取一个，用于构造新的线性约束条件，并将其加入到原松弛问题中形成新的线性规划之后求解。</li><li>重复上述步骤，直至新的松弛问题求得解满足整数条件为止</li><li><strong>每次新增加的线性约束条件应满足两个基本性质</strong><ul><li>已获得的不符合整数要求的线性规划最优解不满足该线性约束条件，从而不可能在以后的解中再出现</li><li>凡整数可行解均满足该线性约束条件，故整数最优解始终被保留在每次形成的线性规划可行域中</li><li><img src="/img/O.R/割平面法.png" alt="割平面法计算步骤"></li></ul></li></ul><h2 id="分配问题与匈牙利法"><a href="#分配问题与匈牙利法" class="headerlink" title="分配问题与匈牙利法"></a>分配问题与匈牙利法</h2><p>分配问题（又称指派问题）：一类特殊的0-1规划问题，可以看成是运输问题的特例<br>问题描述：</p><blockquote><p>假定有 <em>m</em> 项任务分配给 <em>m</em> 个人去完成，并指定每个人完成其中的一项，每项只交给其中一个人去完成，应如何分配才能使总的效率最高。</p></blockquote><p>指派问题的一般数学模型：</p><script type="math/tex; mode=display">\min_{} z = \sum_{i=1}^{m} \sum_{j=1}^{m} c_{ij} x_{ij} \\s.t. \begin{cases}   \displaystyle \sum_{j=1}^{m} x_{ij}=1 \quad (i=1,2,\cdots,m)\\   \displaystyle \sum_{i=1}^{m} x_{ij}=1 \quad (j=1,2,\cdots,m)\\   x_{ij} = 0\ or\ 1 \quad (i=1,2,\cdots,m;j=1,2,\cdots,m) \end{cases}</script><p>若指派问题的系数矩阵为 $(c<em>{ij})</em>{m \times m}$，其最优解为 $x_{ij}(i,j=1,\cdots,m)$，则其最优解与系数矩阵之间有如下性质：</p><blockquote><p>定理：若从系数矩阵 $(c<em>{ij})</em>{m \times m}$的每行（或列）加上或减去一个常数 $u<em>i(or\ v_j)$构成新矩阵 $(c</em>{ij}^{‘})<em>{m \times m}$，其中$c^{‘}</em>{ij}=c<em>{ij}\pm(u_i+v_j)$，则新矩阵 $(c</em>{ij}^{‘})<em>{m \times m}$对应的最优解与原矩阵 $(c</em>{ij})<em>{m \times m}$的最优解 $(x</em>{ij})_{m\times m}$相同</p></blockquote><h3 id="匈牙利法"><a href="#匈牙利法" class="headerlink" title="匈牙利法"></a>匈牙利法</h3><p>原理：找出一组位于 <strong>不同行、不同列</strong> 的0元素（称之为独立的0元素），并令其对应的解元素 $x<em>{ij} = 1$ ，其他元素 $x</em>{ij} = 0$<br>算法的关键：寻找独立的零元素</p><p>匈牙利法求解步骤：</p><ol><li>变换系数矩阵 $(c^{‘}<em>{ij})</em>{m\times m}$，使其各行各列都出现0元素<ul><li>对系数矩阵的每行减去该行的最小元素</li><li>再对上述得到的新的系数矩阵的每列元素中减去该列的最小元素</li></ul></li><li>进行试指派，求得最优解<ol><li>从只有一个0元素的行（列）开始，给这个0元素加圈，记作⭕（其代表对该行所代表的人，只有这一种任务可指派）；之后划去⭕所在列（行）的其它0元素，记作 $\times$（其代表该列所代表的任务已指派完毕，不用再考虑其他人了）</li><li>再给剩下的只有一个0元素列（行）的0元素加圈，记作⭕；之后划去⭕所在行的0元素，记作 $\times$</li><li>反复1、2两步，直至所有0元素都被标记为止。</li><li>若最少0元素行中零元素的个数至少有2个，则从0元素所在列中最少的始加圈，然后划掉 <strong>同行、同列</strong> 的其他0元素，以此类推。</li><li>若矩阵中加圈0元素的个数等于 <em>m</em>（矩阵的阶数），则该指派方案为最优方案。若矩阵中加圈0元素的个数小于 <em>m</em>，则进行下面第三步</li></ol></li><li>作 <strong>最小</strong> 能覆盖 <strong>所有0元素</strong> 的直线集合，由此确定该系数矩阵中能找到最多的 <strong>独立元素数</strong>。依据原理：该直线集合条数 = 已划去的圈数⭕<ol><li>对没有⭕的行打✔</li><li>对已✔行上的所有 $\times$ 元素所在的列打✔</li><li>再对已✔的列上有⭕的行打✔</li><li>重复2、3操作，直至得不到新的打✔行、列为止</li><li>对所有 <strong>没有</strong> ✔的行画一条横线，对所有 <strong>有</strong> ✔的列画纵线，由此得到覆盖所有0元素的最小直线集合</li></ol></li><li>进行调整（对矩阵进行变换，其目的是增加0元素）<ul><li>对直线 <strong>未覆盖区</strong> 的所有元素减去它们中的 <strong>最小数</strong>；<strong>覆盖区的交叉元素</strong> 加上刚才的最小数，其他元素不变，转向步骤 2 继续操作</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输问题</title>
      <link href="/posts/13455.html"/>
      <url>/posts/13455.html</url>
      
        <content type="html"><![CDATA[<h1 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h1><h2 id="运输问题的数学模型"><a href="#运输问题的数学模型" class="headerlink" title="运输问题的数学模型"></a>运输问题的数学模型</h2><p>运输问题的一般提法：</p><blockquote><p>研究单一品种物资的<strong>运输调度问题</strong>，其典型情况是：设某种物品有<strong>m个产地</strong>$(A<em>1,A_2,\cdots,A_m)$,各产地的产量分别是$(a_1,a_2,\cdots,a_m)$；有<strong>n个销地</strong>$(B_1,B_2\cdots,B_n)$，各销地的销量分别为$(b_1,b_2,\cdots,b_n)$。假定从产地$A_i(i=1,2,\cdots,m)$向销地$B_j(j=1,2,\cdots,n)$运输单位物品的运价是$c</em>{ij}$。根据产销关系可以将运输问题分为以下三种类型：</p><script type="math/tex; mode=display">\displaystyle \sum_{i=1}^m a_i = \sum_{j=1}^n b_j\quad \text{产销平衡问题} \\\displaystyle \sum_{i=1}^m a_i > \sum_{j=1}^n b_j\quad \text{供过于求问题} \\\displaystyle \sum_{i=1}^m a_i < \sum_{j=1}^n b_j\quad \text{供不应求问题} \\</script><p>重点考察<strong>产销平衡问题</strong>，用$x_{ij}$表示从$A_i$到$B_j$的运量，那么在产销平衡的条件下，<strong>以运费最小为目标</strong>的运输问题模型可以表示为：</p><script type="math/tex; mode=display">\min_{}\ z\ =\ \displaystyle \sum_{i=1}^m\sum_{j=1}^n c_{ij}x_{ij} \\s.t. \begin{cases}    \displaystyle \sum_{j=1}^n x_{ij}=a_i\ ,\ (i=1,2,\cdots,m) \\    \displaystyle \sum_{i=1}^m x_{ij}=b_j\ ,\ (j=1,2,\cdots,n) \\    x_{ij} \ge 0\ ,\ (i=1,2,\cdots,m\ ;\ j=1,2,\cdots,n)\end{cases}</script></blockquote><p>运输问题模型特点：</p><ul><li><strong>运输问题有有限最优解</strong></li><li><strong>运输问题约束条件的系数矩阵</strong><ul><li>约束条件系数矩阵的元素<strong>等于1或0</strong></li><li>约束条件系数矩阵的每一列有<strong>两个非零元素</strong>，这对应了每一个变量在<strong>前m个</strong>约束方程中出现一次，在<strong>后n个</strong>约束方程中出现一次</li><li>对于产销平衡运输问题，还有以下特点：<ul><li>所有约束条件结构都是<strong>等式约束</strong></li><li>各产地产量之和等于各销地销量之和</li></ul></li></ul></li><li>运输问题模型中包含$m\times n$个变量，$(m+n)$个约束条件，但因为有$\displaystyle \sum<em>{i=1}^m a_i = \sum</em>{j=1}^n b_j$，所以系数矩阵中 <strong>线性独立的列向量的最大个数为$(m+n-1)$个</strong>，即运输问题的解中的 <strong>基变量数不多于$(m+n-1)$个</strong>。</li></ul><hr><h2 id="表上作业法"><a href="#表上作业法" class="headerlink" title="表上作业法"></a>表上作业法</h2><h3 id="求解步骤："><a href="#求解步骤：" class="headerlink" title="求解步骤："></a>求解步骤：</h3><ol><li>初始方案的给定（确定初始基可行解）<ol><li>最小元素法<ul><li>基本思路：运价最低者为优先原则，安排初始的调运方案</li><li>规则：从运价最小的开始，在该格标上允许取得的最大数量。然后继续按照运价从小到大顺序填数，若某行（列）的产量（销量）以满足需求，则把该行（列）的产量（销量）的其它格去掉。重复上述方法进行下去，直到得到一个基本可行解。</li><li>缺点：最小元素法只从局部观点考虑就近供应，可能造成总体的不合理</li></ul></li><li><em>Vogel</em> 法<ul><li>从运价表上分别找出每行与每列的最小的两个元素之差</li><li>再从差值最大的行或列中找出最小运价确定供需关系和供应数量。当产地或销地中有一方数量上供应完毕或得到满足时，划去运价表中对应的行和列</li><li>重复上述步骤，直到产地的产量分配完、销地的销量得到满足时为止。</li><li>一般情况下当 产销地的数量不多时，<em>Vogel</em>法给出的初始方案可能就是最优方案，所以 <em>Vogel</em> 法有时就用作求运输问题最有方案的近似解。</li></ul></li></ol></li><li><p>最优性检验<br>由于运输问题目标函数求的是极小值，因此当所有非基变量的检验数均大于等于零时，则基本可行解为最优解，否则需要进一步调整。</p><ol><li><p>闭回路法</p><blockquote><p>运输问题的闭回路是指 <strong>调运方案中由一个空格和若干个有效数字格的水平和垂直连线包围成的封闭回路</strong><br>构建闭回路的目的时要计算解中各非基变量（对应空格）的检验数。方法是令某非基变量的取值为1，通过变化原基变量的值找出一个新的可行解，将其同原来的基可行解目标函数值作比较。</p></blockquote><p><strong>通过构建的闭回路计算空格对应的非基变量的检验数</strong><br>$\sigma_{ij}=$ 闭回路上第奇数个顶点单位运费之和 - 闭回路上第偶数个顶点单位运费之和。（<strong>其中非基变量为第一个顶点</strong>）<br><strong>一定要是闭回路的顶点才可以参与计算，边途径的点不算</strong></p><p>缺点：当一个运输问题的产地和销地数量很多事，构建闭回路的工作繁重。</p></li><li><p>位势法</p><ul><li>作表将有效数字换成运价表上对应格的运价</li><li>分别在表的下侧添加$v_j(j=1,2,\cdots,n)$，右侧添加$u_i(i=1,2,\cdots,m)$使得表中的有效数字都刚好等于它所在行和列的这些新填数字之和。（这些新添加的数字可以自己赋值）</li><li>利用闭回路法可以得任意空格（非基变量）得检验数字为 $\sigma<em>{ij}=c</em>{ij}-(u<em>i+v_j)$，其中$c</em>{ij}$是该格对应得单位运价表的运价。</li></ul></li></ol></li><li>方案调整改进<ul><li>从检验数为负值得格出发（当有两个以上负检验数时，从 <strong>绝对值</strong> 最大的负检验数格出发），做一条除了该空格以外其余顶点均为有效数字组成的闭回路。在这条闭回路上，对 <strong>运量</strong> 作最大可能的调整。</li><li>在该闭回路上，<strong>偶数顶点</strong>调运量的最小值为调整量 <em>θ</em>，其对应的基变量就是出基变量</li><li>调整：在该闭回路上，<strong>奇数顶点</strong>运输量的数值均加上调整量 <em>θ</em>，<strong>偶数顶点</strong>均减去调整量 <em>θ</em>。则出基变量经过调整后必定为0，该变量由基变量变为非基变量。除此之外，其他顶点运输量保持不变。</li></ul></li></ol><hr><h2 id="产销不平衡的运输问题"><a href="#产销不平衡的运输问题" class="headerlink" title="产销不平衡的运输问题"></a>产销不平衡的运输问题</h2><p>实际问题中产销往往是不平衡的，讨论供过于求问题。<br>当$\displaystyle \sum<em>{i=1}^m a_i &gt; \sum</em>{j=1}^n b_j$（产大于销）时，运输问题数学模型如下所示</p><script type="math/tex; mode=display">\min_{}\ z =\ \displaystyle \sum_{i=1}^m \sum_{j=1}^n c_{ij}x_{ij} \\s.t. \begin{cases}    \displaystyle \sum_{j=1}^n x_{ij} \le a_i \quad (i=1,2,\cdots,m)\\    \displaystyle \sum_{i=1}^m x_{ij} = b_j \quad (j=1,2,\cdots,n)\\    x_{ij} \ge 0\end{cases}</script><p>由于总的产量大于销量，需要考虑多余的物资在哪一个产地就地库存的问题。<br>设 $x_{i,n+1}$ 是产地 $A_i$ 的库存量，于是有</p><script type="math/tex; mode=display">\sum_{j=1}^n x_{ij} + x_{i,n+1} = \sum _{j=1}^{n+1}x_{ij} = a_i \quad (i=1,2,\cdots,m) \\\sum_{i=1}^m x_{ij} = b_j \quad (j=1,2,\cdots,n)\\\sum_{i=1}^m x_{i,n+1}=\sum_{i=1}^m a_i - \sum_{j=1}^n b_j = b_{n+1}</script><p>令</p><script type="math/tex; mode=display">c^{'}_{ij} = c_{ij} \quad (i=1,\cdots,m;j=1,\cdots,n)\\c^{'}_{ij} = 0 \quad (i=1,\cdots,m;j=1,\cdots,n+1)</script><p>将上述式子代入运输问题数学模型中得到新模型</p><script type="math/tex; mode=display">\min_{}\ z^{'}\ =\ \sum_{i=1}^m\sum_{j=1}^{n+1} c^{'}_{ij}x_{ij}=\sum_{j=1}^n c^{'}_{ij}x_{ij} + \sum_{i=1}^{m}c^{'}_{i.n+1}s_{ij}=\sum_{j=1}^n c_{ij}x_{ij}\\s.t. \begin{cases}    \displaystyle \sum_{j=1}^{n+1} x_{ij}=a_i\ ,\ (i=1,2,\cdots,m) \\    \displaystyle \sum_{i=1}^m x_{ij}=b_j\ ,\ (j=1,2,\cdots,n) \\    x_{ij} \ge 0\ ,\ (i=1,2,\cdots,m\ ;\ j=1,2,\cdots,n)\end{cases}</script><p>可以很明显地看出得到的新模型是一个产销平衡地运输问题模型</p><blockquote><p>当供过于求时，只要增加一个假想地销地$j = n+1$（实际上是库存），该销地的总需量为$\displaystyle \sum<em>{i=1}^m a_i - \sum</em>{j=1}^n b<em>j$，而在单位运价表中从个产地到假想销地的单位运价为$c^{‘}</em>{i,n+1} = 0$，于是元运输问题就转换成一个产销平衡的运输问题。<br>类似的，当供不应求时，可以在增加一个假想的产地$i=m+1$，该产地产量为$\displaystyle \sum<em>{j=1}^n b_j - \sum</em>{i=1}^m a<em>i$，在单位运价表上令从该假想产地到各销地的运价为$c^{‘}</em>{m+1,j} = 0$,同样也可以转换成一个产销平衡问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对偶理论</title>
      <link href="/posts/12434.html"/>
      <url>/posts/12434.html</url>
      
        <content type="html"><![CDATA[<h1 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h1><h2 id="对偶问题的提出"><a href="#对偶问题的提出" class="headerlink" title="对偶问题的提出"></a>对偶问题的提出</h2><ul><li>从数学角度，对偶问题可以被理解为<strong>寻找原问题目标函数上届或下届</strong>的问题</li><li><p>一个例子引出对偶问题：</p><blockquote><p>企业A拥有<em>m</em>种资源（有<em>m</em>个约束条件），可以消耗资源生产出<em>n</em>种商品（有<em>n</em>个变量），目标是最大化收入；那么其对偶问题就是，企业B想要购进这些资源，需要确定<em>m</em>种资源的报价（有<em>m</em>个变量），目标是最小化成本，但企业A只有在卖资源的收益不低于卖产品的时候才会同意卖资源（<em>n</em>个约束）。</p></blockquote></li></ul><h2 id="对偶问题的用途"><a href="#对偶问题的用途" class="headerlink" title="对偶问题的用途"></a>对偶问题的用途</h2><ul><li><strong>原问题约束多、变量少时，求解对偶问题能够降低计算时间</strong><br>使用单纯形法时，如果原问题约束多变量少，转换成对偶问题，就是约束少变量多。约束的减少能够有效降低单纯形法的计算时间</li><li><strong>帮助证明原问题无解</strong><br>类似”证明无罪比证明有罪更难“，要证明原问题有解，只需要找出一个满足约束的点，但是想证明原问题无解，总不能遍历所有的点来证明。对偶问题的出现为证明原问题无解提供了新思路。</li><li><strong>便于进行敏感度分析</strong><br>除了得到最优解，我们可能还会关注”如果某些一直条件发生变化，对最优解的影响程度如何“，这就是敏感度分析<ul><li>增加敏感度分析的<strong>直观程度</strong>（对偶问题的最优解就是原问题约束的影子价格）</li><li>在改变某些条件导致原问题无可行解时，可以借助仍然有可行解的对偶问题来分析。</li></ul></li></ul><h2 id="对偶问题的一般形式"><a href="#对偶问题的一般形式" class="headerlink" title="对偶问题的一般形式"></a>对偶问题的一般形式</h2><p>若原问题为$LP_1$</p><script type="math/tex; mode=display">max\ z\ =\ CX \\s.t.\begin{cases}     AX\ \le\  b \\    X\ \ge \ b\end{cases}</script><p>则其对偶问题定义为 $LP_2$</p><script type="math/tex; mode=display">min\ w\ =\ Y^{T}b \\s.t.\begin{cases}    A^{T}Y\ \ge \ C^{T} \\    Y\ \ge \ 0\end{cases}</script><blockquote><p>若原问题并非$LP_1$形式，则我们可以首先将其转化为$LP_1$形式，然后按照前面定义即可计算出其对偶问题。</p><script type="math/tex; mode=display">\sum_{i=1}^na_{ij}x_j\ =\ b_i \implies\ \begin{cases}    \displaystyle \sum_{i=1}^na_{ij}x_j\ \le\ b_i \\    \displaystyle \sum_{i=1}^n-a_{ij}x_j\ \le\ -b_i \end{cases} \\\displaystyle \sum_{i=1}^na_{ij}x_j\ \ge \ b_i\ \implies\ \displaystyle \sum_{i=1}^n-a_{ij}x_j\ \le \ -b_i</script></blockquote><p>可以采用如下方法进行转换：<br><img src="/img/O.R/对偶转换.png" alt="原问题与对偶问题进行转换"></p><p>对照可以看出：</p><ul><li>原问题中求解目标函数极大化，对偶问题求解目标函数极小化</li><li>原问题中约束条件个数等于对偶问题中变量的个数，原问题中变量个数等于对偶问题中约束条件个数</li><li>原问题中约束条件符号为 $\le$，对偶问题中约束条件符号为 $\ge$</li><li>原问题目标函数的系数是其对偶问题约束条件的右端项，而原问题约束条件的右端项是其对偶问题目标函数的系数</li></ul><p>举个例子：</p><blockquote><p>原问题：</p><script type="math/tex; mode=display">\min_{}\ z\ =\ 7x_1\ +\ 4x_2\ -\ 3x_3 \\s.t. \begin{cases}    -4x_1+2x_2-6x_3\ \le \ 24 \\    -3x_1-6x_2-4x_3\ \ge \ 15 \\    \qquad\quad\ \ 5x_2+x_3\ =\ 30\\    x_1\le 0,x_2\text{无约束}，x_3\ge 0\end{cases}</script><p>首先把$C$和<em>b</em>互换，<em>A</em>转置</p><script type="math/tex; mode=display">\max_{}\ w\ =\ 24 \quad 15 \quad 30 \\s.t. \begin{cases}    -4 \quad -3 \quad 0 \quad\  7\\    2 \quad -6 \quad 5 \quad\  4\\    -6 \quad -4 \quad 1 \quad\  -3\\\end{cases}</script><p>最小化转最大化，所以约束条件和原问题变量的符号相反（也就是表格中从右往左），变量和原问题约束条件符号相同：</p><script type="math/tex; mode=display">\max_{}\ w\ =\ 24y_1\ +\ 15y_2 \ +\ 30y_3 \\s.t. \begin{cases}    -4y_1 -3y_2 \quad \quad\ \ \ge7\\    2y_1 -6y_2+5y_3\ \ \ = 4\\    -6y_1 -4y_2 +1y_3\le   -3\\\end{cases}</script><hr><h2 id="对偶问题的基本性质"><a href="#对偶问题的基本性质" class="headerlink" title="对偶问题的基本性质"></a>对偶问题的基本性质</h2><ol><li><strong>弱对偶性</strong>：如果$X$是原问题的可行解，$Y$是对偶问题的可行解，则$CX\ \le\ Y^{T}b$<br>证明：$Y^{T}\ge Y^{T}AX\ =\ (Y^{T}AX)^{T}\ =\ X^{T}A^{T}Y\ge X^{T}C^{T}\ =\ CX$<br>推论：<ul><li><strong>最优性</strong>：如果$X$是原问题的可行解，$Y$是对偶问题的可行解, 且$CX\ =\ Y^{T}b$，则$X$和$Y$分别为原问题和对偶问题的最优解</li><li><strong>无界性</strong>：如果原问题（对偶问题）具有无界解，则其对偶问题（原问题）无可行解</li></ul></li><li><strong>强对偶性</strong>：如果原问题有最优解，则其对偶问题也一定具有最优解，<br>且$\max<em>{}\ z\ =\ \min</em>{}\ w$<br>证明：设<em>B</em>为原问题标准形式的可行解基，且其基解为最优解，则由最优性条件应有检验数全部小于等于零：<br>$-C<em>{B}B^{-1}\le 0,\theta=C-C</em>{B}B^{-1}A\le 0$<br>从而可得：<br>$A^{T}B^{-T}C^{T}<em>B\ge C^{T},B^{-T}C^{T}_B\ge 0$<br>所以$B^{-T}C^{T}_B$是对偶问题的一个可行解，且<br>$(B^{-T}C^{T}_B)^{T}b=C_BB^{-1}b=\max</em>{}\ z$<br>由最优性可知，$B^{-T}C^{T}<em>B$为对偶问题的最优解，且$\max</em>{}\ z\ =\ \min_{}\ w$</li><li><strong>互补松弛性</strong>：在线性规划问题的最优解中，如果某一约束条件的对偶变量值非零，则该约束条件严格取等，反之，如果约束条件取不等式，则对应的对偶变量一定为0，可以表示为$Y^{T}(b-AX)\ =\ 0$<br>证明：由强弱偶性可知$CX\ =\ Y^{T}b$，<br>又$\because\ CX=X^{T}C^{T}\le X^{T}A^{T}Y=Y^{T}AX\le Y^{T}b$<br>$\therefore Y^{T}AX=Y^{T}b \implies Y^{T}(b-AX)\ =\ 0$</li><li><strong>基解互补性</strong>：原问题及其对偶问题之间存在一对互补的基解，其中原问题的松弛变量对应对偶问题的变量对偶问题的剩余变量对应原问题的变量.这些互相对应的变量如果在一个问题的解中是基变量则在另一个问题的解中是非基变量；将这对互补的集解分别带入原问题和对偶问题的目标函数中有$z\ =\ w$</li></ol></blockquote><hr><h2 id="影子价格"><a href="#影子价格" class="headerlink" title="影子价格"></a>影子价格</h2><p>考察如下对偶问题</p><script type="math/tex; mode=display">max\ z\ =\ CX \quad \quad min\ w\ =\ Y^{T}b \\\\s.t.\begin{cases}     AX\ \le\  b \\    X\ \ge \ b\end{cases}\quad \quad s.t.\begin{cases}    A^{T}Y\ \ge \ C^{T} \\    Y\ \ge \ 0\end{cases}</script><blockquote><p>定义：若<em>P</em>的某个约束条件的右端项常数 $b_i$ (第<em>i</em>种资源的拥有量）增加一个单位时，所引起目标函数最优值 $z^{<em>}$ 的改变量称为第</em>i*种资源的影子价格，其值等于对偶问题中对偶变量$y_i$.</p></blockquote><p>假设 $X^{<em>}$和$Y^{</em>}$ 分别为原问题和对偶问题的最优解，由对偶问题的基本性质有</p><script type="math/tex; mode=display">z^{*}=\sum c_j x_j^{*}=\sum b_j y_j^{*}</script><p>$\because$ 某个 $\Delta b_i=1$，所以最优解的变化 $\Delta z^{<em>}=y_i^{</em>}$<br>也就是对偶变量 $y_i$ 就是第<em>i</em>个产品的影子价格 $\displaystyle \frac{\partial z^{<em>}}{\partial b_i}=y^{</em>}_i$</p><p>影子价格是在资源最优利用条件下对单位资源的估价，这种估价不是资源实际的市场价格。<strong>影子价格是一种机会成本</strong>。</p><h3 id="根据影子价格得出的结论"><a href="#根据影子价格得出的结论" class="headerlink" title="根据影子价格得出的结论"></a>根据影子价格得出的结论</h3><p>假设某种资源的单位市场价是$m_i$，则</p><ul><li>当$j_i^{<em>} &gt; m_i$时，企业购进这种资源后<strong>增加的利润</strong>多于<strong>资源收购价</strong>，<strong>单位纯利</strong>为$j_i^{</em>} - m_i$，企业有利可图</li><li>相反，当$j_i^{<em>} &lt; m_i$时，则企业会选择有偿转让这种资源，可获<strong>单位纯利</strong>$j_i^{</em>} - m_i$，否则企业无利可图，甚至亏损</li></ul><p>根据<strong>互补松弛性</strong>：$Y^{T}(b-AX)\ =\ 0$，可以进一步得出结论：</p><ul><li>生产过程中如果某种资源未得到充分利用时（资源约束不严格取等），该种资源的影子价格为0（对偶问题的最优解对应变量为0）</li><li>若当资源的影子价格不为0时，表明该种资源在生产中已耗费完（资源约束严格取等）</li></ul><p><strong>影子价格对单纯形表计算的解释</strong><br>在单纯形表中的检验数为$\sigma<em>j=c_j-C_BB^{-1}P_j=c_j-\displaystyle \sum</em>{i=1}^m a<em>{ij}y_i$，其中$c_j$代表第<em>j</em>种产品的产值，$\displaystyle \sum</em>{i=1}^m a_{ij}y_i$代表生产一个单位该种产品所消耗的各项资源的影子价格的总和，即产品的<strong>机会成本</strong><br>则检验数$\sigma_j$的经济意义如下</p><ul><li>当$\sigma_j&gt;0$时，即产值大于记会成本时，表明生产该项产品更有利，可在计划中安排</li><li>反之，当$\sigma_j&lt;0$时，表明用这些资源生产别的产品更有利，不应用于生产该产品</li></ul><hr><h2 id="对偶单纯形法"><a href="#对偶单纯形法" class="headerlink" title="对偶单纯形法"></a>对偶单纯形法</h2><p>对偶单纯形法是求解线性规划的另一个基本方法。它是根据对偶原理和单纯形法原理而设计出来的，因此称为对偶单纯形法。对偶单纯性法提高了对求解线性规划问题的效率，它通常具有以下优点：</p><ul><li>初始基解可以是非可行解, 当检验数都为负值时, 就可以进行基的变换, 不需加入人工变量, 从而简化计算；</li><li>对于变量多于约束条件的线性规划问题,用对偶单纯形法可以减少计算量,在灵敏度分析及求解整数规划的割平面法中,有时适宜用对偶规划单纯形法。</li></ul><p>而在对偶单纯形方法中，我们要求：所有检验数$\sigma&lt;0$，但是<em>b</em>无要求。这时我们希望通过转化可行解使得$b=(b_1,b_2,\cdots,b_m)^{T}$更接近$\ge 0$，同时保持$\sigma\le 0$，直到$b\ge 0$，找到最优解。</p><h3 id="对偶单纯形法计算步骤："><a href="#对偶单纯形法计算步骤：" class="headerlink" title="对偶单纯形法计算步骤："></a>对偶单纯形法计算步骤：</h3><ol><li><strong>确定换出基变量</strong><br>对于小于零的$b<em>i$，令$b_r=\min</em>{}(b_i)$，所对应的变量$x_r$为换出基变量。</li><li><strong>确定换入基变量</strong><ol><li>为使迭代后的表中第<em>r</em>行基变量为正值，<br>因而只有对应$a_{rj}&lt;0(j=m+1,\cdots,n)$(系数均为负数)的非基变量才可以考虑</li><li>为使迭代后表中对偶问题的解仍为可行解，令<script type="math/tex; mode=display">\displaystyle \theta = \min_{j}\left\{ \frac{\sigma_j}{a_{rj}} \mid a_{rj}<0 \right\} = \frac{\sigma_s}{a_{rs}}</script>称$a_{rs}$为主元素，$x_s$为换入基变量</li></ol></li><li><strong>用换入基变量替换换出基变量，得到一个新的基</strong><br>进行初等行变换后，检查所有$b_i$是否$\ge 0$</li><li>重复上述三个步骤，直至$b\ge 0$</li></ol><p>单纯行表如下：<br><img src="/img/O.R/对偶单纯形表.png" alt="对偶单纯形表"></p><h3 id="单纯形法与对偶单纯形法的比较"><a href="#单纯形法与对偶单纯形法的比较" class="headerlink" title="单纯形法与对偶单纯形法的比较"></a>单纯形法与对偶单纯形法的比较</h3><center>    <!-- 单纯形法与对偶单纯形法的比较 --><table border="1" style="margin: auto；" width='80%'>    <tr>        <td></td>        <td style="text-align:center"><b>单纯形法</b></td>        <td style="text-align:center"><b>对偶单纯形法</b></td>    </tr>    <tr>        <td style="text-align:center">原理</td>        <td style="text-align:center">保证原问题是可行解的情况下            向对偶问题可行的方向迭代        </td>        <td style="text-align:center">保证对偶问题是可行解的情况下            向原问题可行的方向迭代</td>    </tr>    <tr>        <td style="text-align:center">限制条件</td>        <td style="text-align:center">单纯形表的 <i>b ≥ 0</i>（找到基可行解）</td>        <td style="text-align:center">检验数字 <i>σ ≤ 0</i></td>    </tr>    <tr>        <td style="text-align:center">最优解判断</td>        <td style="text-align:center">看非基变量的检验数是否都 <i>≤ 0</i></td>        <td style="text-align:center">看对偶单纯形表的 <i>b </i>是否都 <i>≥ 0</i></td>    </tr>    <tr>        <td style="text-align:center">变量替换</td>        <td style="text-align:center">先确定入基变量，最小换最大</td>        <td style="text-align:center">先确定换出变量，最小换最大</td>    </tr></table></center><hr><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>在前面的线性规划问题中，我们都是假定问题中的$A,b,C$是已知的。但是实际上这些参数往往是一些估计和预测的数字，如市场条件发生变化，<em>C</em>的值就会变化，<em>A</em>会随着工艺技术条件的改变而改变，而<em>b</em>则是根据资源投入后能产生多大经济效果来决定的一种决策选择。</p><p>因而一个自然的问题就是当这些参数中的一个或者几个发生变化时，问题的最优解会有什么变化，或者这些参数在一个多大的范围内变化时，问题的最优解或者最优基不变，这就是灵敏度分析所要解决的问题。</p><p>在使用单纯形法解决线性规划问题时，我们需要先通过初等行变换基变量对应的子矩阵化为单位矩阵，因此存在一个方阵<em>D</em>使得$\displaystyle D(A\ b) = (A^{‘}\ b^{‘})$，易得$D\ =\ B^{-1}$，一般来讲，我们考虑如下几种问题的变化：</p><ol><li>当某个$c<em>j$变化时，$A^{‘}\ b^{‘}$无变化，非基变量的检验数$\Delta\sigma_j=-a</em>{ij}\Delta c_j$，要让最优解不发生变化，我们要求所有$\sigma^{*}_j=\sigma_j+\Delta\sigma_j\le 0$</li><li>当某个$b_j$变化时，$\Delta b^{‘}=B^{-1}\Delta b$，要让最优解不发生变化，我们要求<br>$b^{*}=b+B^{-1}\Delta b\ge 0$</li><li>增加某个变量$x_j$，对应的系数列向量为$P_j$，则单纯形表中需要新添加一列<br>$P^{‘}_j=B^{-1}P_j$，然后计算相应的检验数，继续用单纯形法计算最优解</li><li>增加一个约束条件，新产生一个剩余变量或者松弛变量，或者用前面学过的方法添加人工变量，将新变量加入基变量，重整单纯性表，根据 <em>b</em> 和 $\sigma$ 的情况选择方法求出最优解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单纯形法</title>
      <link href="/posts/15656.html"/>
      <url>/posts/15656.html</url>
      
        <content type="html"><![CDATA[<h1 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h1><h2 id="线性规划一般形式"><a href="#线性规划一般形式" class="headerlink" title="线性规划一般形式"></a>线性规划一般形式</h2><p>在约束条件下、寻找目标函数 <em>z</em> 的最大值</p><script type="math/tex; mode=display">max(or \ min) \ z = \displaystyle\sum_{j=1}^n c_jx_j \\s.t. \begin{cases}   \displaystyle\sum_{j=1}^n a_{ij}\ \leq\ (or\ =,\geq)\ b_i\quad(i\ = 1,...,m) \\   \\   x_j\ \geq \ 0 \qquad \qquad \qquad \quad \ \ \  (j\ = 1,...,n)\end{cases}</script><h2 id="线性规划的标准形式"><a href="#线性规划的标准形式" class="headerlink" title="线性规划的标准形式"></a>线性规划的标准形式</h2><p>标准形需要满足的条件：</p><ol><li>目标函数求<strong>最大值</strong> <em>max</em></li><li>约束条件均为<strong>等式</strong></li><li>所有决策变量均为<strong>非负约束</strong></li><li>约束条件右端常数项 $b_i$ 全为非负值 </li></ol><p>一般来说，规定线性规划的标准形式为：</p><script type="math/tex; mode=display">max\ z = \displaystyle\sum_{j=1}^n c_jx_j \\s.t. \begin{cases}   \displaystyle\sum_{j=1}^n a_{ij}\ =\ b_i\qquad \qquad(i\ = 1,...,m) \\   \\   x_j\ \geq \ 0\ ,\ b_i\ \geq \ 0 \qquad (j\ = 1,...,n)\end{cases}</script><p>可以写成矩阵形式：</p><script type="math/tex; mode=display">max\ z\ = CX \\AX\ =\ b \\X\ \geq \ 0 \\ A\ =\ \begin{pmatrix}  a_{11} & a_{12} & \cdots & a_{1n} \\\vdots & \vdots & \ddots & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn}\end{pmatrix}</script><p>将一般线性规划问题化为标准型：</p><ol><li>目标函数极大化。（可通过取相反数实现）</li><li>将不等式约束条件通过添加松弛变量得到方法华为等式<ul><li>约束条件为 $\leq$ 不等式，则在约束条件的左端加上一个非负的松弛变量；</li><li>约束条件为 $\geq$ 不等式，则在约束条件的左端减去一个非负的松弛变量。</li></ul></li><li>取值无约束的变量：<ul><li>若存在<strong>无约束的变量</strong>$x_k$，可令 $x_k\ = x_k^{‘}\ -\ x_k^{‘’}$，其中 $x_k^{‘}，x_k^{‘’}\  \ge \ 0$。</li></ul></li></ol><hr><h2 id="单纯形法求解"><a href="#单纯形法求解" class="headerlink" title="单纯形法求解"></a>单纯形法求解</h2><p>几个基本定理：</p><ul><li>若线性规划问题存在可行解，则问题的可行域是凸集<ul><li>引理：线性规划问题的可行解 $X\ =\ (x_1,\cdots,x_n)^{T}$ 为基可行解的充要条件是 $X$ 的正分量所对应的系数列向量是线性无关的。</li></ul></li><li>线性规划问题的基可行解 $X$ 对应线性规划问题可行域（凸集）的顶点</li><li>若线性规划问题有最优解一定存在一个基可行解是最优解</li></ul><p>单纯形法求解过程：</p><ol><li>化为标准型（要求 $b \ge 0$）,确定初始基<em>B</em>，建立<strong>初始单纯行表</strong>(假设<em>A</em>矩阵中存在<strong>单位矩阵</strong>)<br><img src="/img/O.R/初始单纯形表.png" alt="初始单纯行表"></li><li>其中:<script type="math/tex; mode=display">\theta\ =\ \min{(\frac{b_i}{a_{ik}}\ |\ a_{ik}\ >\ 0)}</script></li><li>若 $\sigma_j\ \le 0\ (j\ =\ m+1,\cdots,n)$，则已得到最优解，否则转入下一步</li><li>若在 $j\ =\ m+1,\cdots,n$ 中，存在 $\sigma_k\ &gt;\ 0$, 而 $P_k\ &lt;\ 0$，则无最优解。</li><li>确定换入变量和换出变量<ul><li>由 $\max(\sigma_k&gt;0)\ =\ \sigma_k$，确定 $x_k$ 为换入变量</li><li>由<script type="math/tex; mode=display">\theta\ =\ \min{(\frac{b_i}{a_{ik}}\ |\ a_{ik}\ >\ 0)}\ = \frac{b_l}{a_{lk}}</script>确定 $x_l$ 为换出变量。</li></ul></li><li>以 $a_{lk}$ 为主元进行迭代<br>即将<script type="math/tex; mode=display">P_k=\begin{pmatrix}   a_{1k} \\   \vdots \\   a_{lk} \\   \vdots \\   a_{mk}\end{pmatrix}迭代成\begin{pmatrix}   0 \\   \vdots \\   0 \\   1 \\   0 \\   \vdots \\   0\end{pmatrix}\to l行</script></li><li>重复 2~5 步骤</li></ol><h3 id="单纯形法进一步讨论"><a href="#单纯形法进一步讨论" class="headerlink" title="单纯形法进一步讨论"></a>单纯形法进一步讨论</h3><ul><li>人工变量法（大M法）<ul><li>凑单位矩阵添加人工变量</li><li>目标函数中人工变量的系数为足够大的一个负值，用“$-M$”表示</li></ul></li><li>两阶段法<ul><li>第一阶段实现求解一个目标函数中只包含人工变量的线性规划问题（令目标函数中其他变量的系数取零），人工变量的系数取某个<strong>正的常数</strong>（一般取1），在保持<strong>原问题约束条件不变</strong>的情况下求这个目标函数的<strong>极小值</strong><ul><li>当人工变量取值为0时，目标函数值也为0，这时的最优解就是原线性规划问题的的一个可行解</li><li>如果第一阶段求解结果表明最优解的目标函数值不为0，即最优解的基变量中含有人工变量，则表明原线性规划问题无可行解</li></ul></li><li>第一阶段表明问题有可行解时，第二阶段从第一阶段的最终单纯形表出发，去掉人工变量，并按问题原来的目标函数，继续寻找问题的最优解</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 应试 </category>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O.R </tag>
            
            <tag> 考试！考试！考试！😫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
